{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction gitbook install gitbook build ./ ./docs --clean gitp Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-02 22:02:27 "},"map-foreach.html":{"url":"map-foreach.html","title":"map遍历","keywords":"","body":"Java中遍历Map的几种方法 keySet values 如果只需要map的key或者value，用map的keySet或values方法无疑是最方便的 for (String key : map.keySet()) { System.out.println(key); } keySet get(key) 如果需要同时获取key和value，可以先获取key,然后再通过map的get(key)获取value 需要说明的是，该方法不是最优选择，一般不推荐使用 for (String key : map.keySet()) { System.out.println(key); System.out.println(map.get(key)); } entrySet 通过对map entrySet的遍历，也可以同时拿到key和value，一般情况下，性能上要优于上一种,这一种也是最常用的遍历方法 for (Map.Entry entry : map.entrySet()) { System.out.println(entry.getKey()); System.out.println(entry.getValue()); } Iterator 对于上面的几种foreach都可以用Iterator代替，其实foreach在java5中才被支持，foreach的写法看起来更简洁 但Iterator也有其优势：在用foreach遍历map时，如果改变其大小，会报错，但如果只是删除元素，可以使用Iterator的remove方法删除元素 Iterator> iterator = map.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry entry = iterator.next(); System.out.println(entry.getKey()); System.out.println(entry.getValue()); iterator.remove();//删除元素 } Lambda java8提供了Lambda表达式支持，语法看起来更简洁，可以同时拿到key和value，不过，经测试，性能低于entrySet,所以更推荐用entrySet的方式 map.forEach((key,value)->{ System.out.println(key); System.out.println(value); }); 总结 如果只是获取key，或者value，推荐使用keySet或者values方式 如果同时需要key和value推荐使用entrySet 如果需要在遍历过程中删除元素推荐使用Iterator 如果需要在遍历过程中增加元素，可以新建一个临时map存放新增的元素，等遍历完毕，再把临时map放到原来的map中 Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-02 21:09:07 "},"regex.html":{"url":"regex.html","title":"正则表达式","keywords":"","body":"正则表达式，一个十分古老而又强大的文本处理工具，仅仅用一段非常简短的表达式语句，便能够快速实现一个非常复杂的业务逻辑。熟练地掌握正则表达式的话，能够使你的开发效率得到极大的提升。 正则表达式经常被用于字段或任意字符串的校验，如下面这段校验基本日期格式的JavaScript代码： var reg = /^(\\\\d{1,4})(-|\\\\/)(\\\\d{1,2})\\\\2(\\\\d{1,2})$/; var r = fieldValue.match(reg); if(r==null)alert('Date format error!'); 下面是技匠整理的，在前端开发中经常使用到的20个正则表达式。 1 . 校验密码强度 密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。 ^(?=.*\\\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 2. 校验中文 字符串仅能是中文。 ^[\\\\\\u4e00-\\\\\\u9fa5]{0,}$ 3. 由数字、26个英文字母或下划线组成的字符串 ^\\\\w+$ 4. 校验E-Mail 地址 同密码一样，下面是E-mail地址合规性的正则检查语句。 [\\\\w!#$%&'*+/=?^_`{|}~-]+(?:\\\\.[\\\\w!#$%&'*+/=?^_`{|}~-]+)*@(?:[\\\\w](?:[\\\\w-]*[\\\\w])?\\\\.)+[\\\\w](?:[\\\\w-]*[\\\\w])? 5. 校验身份证号码 下面是身份证号码的正则校验。15 或 18位。 15位： ^[1-9]\\\\d{7}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}$ 18位： ^[1-9]\\\\d{5}[1-9]\\\\d{3}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}([0-9]|X)$ 6. 校验日期 “yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。 ^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$ 7. 校验金额 金额校验，精确到2位小数。 ^[0-9]+(.[0-9]{2})?$ 8. 校验手机号 下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码） ^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\\\d{8}$ 9. 判断IE的版本 IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。 ^.*MSIE [5-8](?:\\\\.[0-9]+)?(?!.*Trident\\\\/[5-9]\\\\.0).*$ 10. 校验IP-v4地址 IP4 正则语句。 \\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b 11. 校验IP-v6地址 IP6 正则语句。 (([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 12. 检查URL的前缀 应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。 if (!s.match(/^[a-zA-Z]+:\\\\/\\\\//)) { s = 'http://' + s; } 13. 提取URL链接 下面的这个表达式可以筛选出一段文本中的URL。 ^(f|ht){1}(tp|tps):\\\\/\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%&=]*)? 14. 文件路径及扩展名校验 验证windows下文件路径和扩展名（下面的例子中为.txt文件） ^([a-zA-Z]\\\\:|\\\\\\\\)\\\\\\\\([^\\\\\\\\]+\\\\\\\\)*[^\\\\/:*?\"<>|]+\\\\.txt(l)?$ 15. 提取Color Hex Codes 有时需要抽取网页中的颜色代码，可以使用下面的表达式。 ^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ 16. 提取网页图片 假若你想提取网页中所有图片信息，可以利用下面的表达式。 \\\\]*[src] *= *[\\\\\"\\\\']{0,1}([^\\\\\"\\\\'\\\\ >]*) 17. 提取页面超链接 提取html中的超链接。 (]*)(href=\"https?:\\\\/\\\\/)((?!(?:(?:www\\\\.)?'.implode('|(?:www\\\\.)?', $follow_list).'))[^\"]+)\"((?!.*\\\\brel=)[^>]*)(?:[^>]*)> 18. 查找CSS属性 通过下面的表达式，可以搜索到相匹配的CSS属性。 ^\\\\s*[a-zA-Z\\\\-]+\\\\s*[:]{1}\\\\s[a-zA-Z0-9\\\\s.#]+[;]{1} 19. 抽取注释 如果你需要移除HMTL中的注释，可以使用如下的表达式。 20. 匹配HTML标签 通过下面的表达式可以匹配出HTML中的标签属性。 \\\\s]+))?)+\\\\s*|\\\\s*)\\\\/?> Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-02 21:09:07 "},"java-generic.html":{"url":"java-generic.html","title":"泛型详解","keywords":"","body":" 引言 ​ 泛型是Java中一个非常重要的知识点，在Java集合类框架中泛型被广泛应用。本文我们将从零开始来看一下Java泛型的设计，将会涉及到通配符处理，以及让人苦恼的类型擦除。 泛型基础 泛型类 ​ 我们首先定义一个简单的Box类： public class Box { private String object; public void set(String object) { this.object = object; } public String get() { return object; } } ​ 这是最常见的做法，这样做的一个坏处是Box里面现在只能装入String类型的元素，今后如果我们需要装入Integer等其他类型的元素，还必须要另外重写一个Box，代码得不到复用，使用泛型可以很好的解决这个问题。 public class Box { // T stands for \"Type\" private T t; public void set(T t) { this.t = t; } public T get() { return t; } } ​ 这样我们的Box类便可以得到复用，我们可以将T替换成任何我们想要的类型： Box integerBox = new Box(); Box doubleBox = new Box(); Box stringBox = new Box(); 泛型方法 ​ 看完了泛型类，接下来我们来了解一下泛型方法。声明一个泛型方法很简单，只要在返回类型前面加上一个类似的形式就行了： public class Util { public static boolean compare(Pair p1, Pair p2) { return p1.getKey().equals(p2.getKey()) && p1.getValue().equals(p2.getValue()); } } public class Pair { private K key; private V value; public Pair(K key, V value) { this.key = key; this.value = value; } public void setKey(K key) { this.key = key; } public void setValue(V value) { this.value = value; } public K getKey() { return key; } public V getValue() { return value; } } ​ 我们可以像下面这样去调用泛型方法： Pair p1 = new Pair<>(1, \"apple\"); Pair p2 = new Pair<>(2, \"pear\"); boolean same = Util.compare(p1, p2); ​ 或者在Java1.7/1.8利用type inference，让Java自动推导出相应的类型参数： Pair p1 = new Pair<>(1, \"apple\"); Pair p2 = new Pair<>(2, \"pear\"); boolean same = Util.compare(p1, p2); 边界符:extends ​ 现在我们要实现这样一个功能，查找一个泛型数组中大于某个特定元素的个数，我们可以这样实现： public static int countGreaterThan(T[] anArray, T elem) { int count = 0; for (T e : anArray) if (e > elem) // compiler error ++count; return count; } ​ 但是这样很明显是错误的，因为除了short, int, double, long, float, byte, char等原始类型，其他的类并不一定能使用操作符>，所以编译器报错，那怎么解决这个问题呢？答案是使用边界符。 public interface Comparable { public int compareTo(T o); } ​ 做一个类似于下面这样的声明，这样就等于告诉编译器类型参数T代表的都是实现了Comparable接口的类，这样等于告诉编译器它们都至少实现了compareTo方法。 public static > int countGreaterThan(T[] anArray, T elem) { int count = 0; for (T e : anArray) if (e.compareTo(elem) > 0) ++count; return count; } 通配符: ? ​ 在了解通配符之前，我们首先必须要澄清一个概念，还是借用我们上面定义的Box类，假设我们添加一个这样的方法： public void boxTest(Box n) { /* ... */ } ​ 那么现在Box n允许接受什么类型的参数？我们是否能够传入Box或者Box呢？答案是否定的，虽然Integer和Double是Number的子类，但是在泛型中Box或者Box与Box之间并没有任何的关系。这一点非常重要，接下来我们通过一个完整的例子来加深一下理解。 ​ 首先我们先定义几个简单的类，下面我们将用到它： class Fruit {} class Apple extends Fruit {} class Orange extends Fruit {} ​ 下面这个例子中，我们创建了一个泛型类Reader，然后在f1()中当我们尝试Fruit f = fruitReader.readExact(apples);编译器会报错，因为List与List之间并没有任何的关系。 public class GenericReading { static List apples = Arrays.asList(new Apple()); static List fruit = Arrays.asList(new Fruit()); static class Reader { T readExact(List list) { return list.get(0); } } static void f1() { Reader fruitReader = new Reader(); // Errors: List cannot be applied to List. Fruit f = fruitReader.readExact(apples); } public static void main(String[] args) { f1(); } } ​ 但是按照我们通常的思维习惯，Apple和Fruit之间肯定是存在联系，然而编译器却无法识别，那怎么在泛型代码中解决这个问题呢？我们可以通过使用通配符来解决这个问题： static class CovariantReader { T readCovariant(List list) { return list.get(0); } } static void f2() { CovariantReader fruitReader = new CovariantReader(); Fruit f = fruitReader.readCovariant(fruit); Fruit a = fruitReader.readCovariant(apples); } public static void main(String[] args) { f2(); } ​ 这样就相当与告诉编译器， fruitReader的readCovariant方法接受的参数只要是满足Fruit的子类就行(包括Fruit自身)，这样子类和父类之间的关系也就关联上了。 PECS原则: super ​ 上面我们看到了类似的用法，利用它我们可以从list里面get元素，那么我们可不可以往list里面add元素呢？我们来尝试一下： public class GenericsAndCovariance { public static void main(String[] args) { // Wildcards allow covariance: List flist = new ArrayList(); // Compile Error: can't add any type of object: // flist.add(new Apple()) // flist.add(new Orange()) // flist.add(new Fruit()) // flist.add(new Object()) flist.add(null); // Legal but uninteresting // We Know that it returns at least Fruit: Fruit f = flist.get(0); } } ​ 答案是否定，Java编译器不允许我们这样做，为什么呢？对于这个问题我们不妨从编译器的角度去考虑。因为List flist它自身可以有多种含义： List flist = new ArrayList(); List flist = new ArrayList(); List flist = new ArrayList(); ​ 当我们尝试add一个Apple的时候，flist可能指向new ArrayList(); ​ 当我们尝试add一个Orange的时候，flist可能指向new ArrayList(); ​ 当我们尝试add一个Fruit的时候，这个Fruit可以是任何类型的Fruit，而flist可能只想某种特定类型的Fruit，编译器无法识别所以会报错。 所以对于实现了的集合类只能将它视为Producer向外提供(get)元素，而不能作为Consumer来对外获取(add)元素。 ​ 如果我们要add元素应该怎么做呢？可以使用： public class GenericWriting { static List apples = new ArrayList(); static List fruit = new ArrayList(); static void writeExact(List list, T item) { list.add(item); } static void f1() { writeExact(apples, new Apple()); writeExact(fruit, new Apple()); } static void writeWithWildcard(List list, T item) { list.add(item) } static void f2() { writeWithWildcard(apples, new Apple()); writeWithWildcard(fruit, new Apple()); } public static void main(String[] args) { f1(); f2(); } } ​ 这样我们可以往容器里面添加元素了，但是使用super的坏处是以后不能get容器里面的元素了，原因很简单，我们继续从编译器的角度考虑这个问题，对于List list，它可以有下面几种含义： List list = new ArrayList(); List list = new ArrayList(); List list = new ArrayList(); ​ 当我们尝试通过list来get一个Apple的时候，可能会get得到一个Fruit，这个Fruit可以是Orange等其他类型的Fruit。 根据上面的例子，我们可以总结出一条规律，”Producer Extends, Consumer Super”： ​ “Producer Extends” – 如果你需要一个只读List，用它来produce T，那么使用? extends T。 ​ “Consumer Super” – 如果你需要一个只写List，用它来consume T，那么使用? super T。 ​ 如果需要同时读取以及写入，那么我们就不能使用通配符了。 ​ 如何阅读过一些Java集合类的源码，可以发现通常我们会将两者结合起来一起用，比如像下面这样： public class Collections { public static void copy(List dest, List src) { for (int i=0; i 类型擦除 ​ Java泛型中最令人苦恼的地方或许就是类型擦除了，特别是对于有C++经验的程序员。类型擦除就是说Java泛型只能用于在编译期间的静态类型检查，然后编译器生成的代码会擦除相应的类型信息，这样到了运行期间实际上JVM根本就知道泛型所代表的具体类型。这样做的目的是因为Java泛型是1.5之后才被引入的，为了保持向下的兼容性，所以只能做类型擦除来兼容以前的非泛型代码。对于这一点，如果阅读Java集合框架的源码，可以发现有些类其实并不支持泛型。 ​ 说了这么多，那么泛型擦除到底是什么意思呢？我们先来看一下下面这个简单的例子： public class Node { private T data; private Node next; public Node(T data, Node next) { this.data = data; this.next = next; } public T getData() { return data; } // ... } ​ 编译器做完相应的类型检查之后，实际上到了运行期间上面这段代码实际上将转换成： public class Node { private Object data; private Node next; public Node(Object data, Node next) { this.data = data; this.next = next; } public Object getData() { return data; } // ... } ​ 这意味着不管我们声明Node还是Node，到了运行期间，JVM统统视为Node。有没有什么办法可以解决这个问题呢？这就需要我们自己重新设置bounds了，将上面的代码修改成下面这样： public class Node> { private T data; private Node next; public Node(T data, Node next) { this.data = data; this.next = next; } public T getData() { return data; } // ... } ​ 这样编译器就会将T出现的地方替换成Comparable而不再是默认的Object了： public class Node { private Comparable data; private Node next; public Node(Comparable data, Node next) { this.data = data; this.next = next; } public Comparable getData() { return data; } // ... } ​ 上面的概念或许还是比较好理解，但其实泛型擦除带来的问题远远不止这些，接下来我们系统地来看一下类型擦除所带来的一些问题，有些问题在C++的泛型中可能不会遇见，但是在Java中却需要格外小心。 问题一(不能创建泛型数组对象) 在Java中不允许创建泛型数组，类似下面这样的做法编译器会报错： List[] arrayOfLists = new List[2]; // compile-time error ​ 为什么编译器不支持上面这样的做法呢？继续使用逆向思维，我们站在编译器的角度来考虑这个问题。 ​ 我们先来看一下下面这个例子： Object[] strings = new String[2]; strings[0] = \"hi\"; // OK strings[1] = 100; // An ArrayStoreException is thrown. ​ 对于上面这段代码还是很好理解，字符串数组不能存放整型元素，而且这样的错误往往要等到代码运行的时候才能发现，编译器是无法识别的。接下来我们再来看一下假设Java支持泛型数组的创建会出现什么后果： Object[] stringLists = new List[]; // compiler error, but pretend it's allowed stringLists[0] = new ArrayList(); // OK // An ArrayStoreException should be thrown, but the runtime can't detect it. stringLists[1] = new ArrayList(); ​ 假设我们支持泛型数组的创建，由于运行时期类型信息已经被擦除，JVM实际上根本就不知道new ArrayList()和new ArrayList()的区别。类似这样的错误假如出现才实际的应用场景中，将非常难以察觉。 ​ 如果你对上面这一点还抱有怀疑的话，可以尝试运行下面这段代码： public class ErasedTypeEquivalence { public static void main(String[] args) { Class c1 = new ArrayList().getClass(); Class c2 = new ArrayList().getClass(); System.out.println(c1 == c2); // true } } 问题二(调用父类泛型方法的时候有个类型转换) ​ 继续复用我们上面的Node的类，对于泛型代码，Java编译器实际上还会偷偷帮我们实现一个Bridge method。 public class Node { public T data; public Node(T data) { this.data = data; } public void setData(T data) { System.out.println(\"Node.setData\"); this.data = data; } } public class MyNode extends Node { public MyNode(Integer data) { super(data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } } ​ 看完上面的分析之后，你可能会认为在类型擦除后，编译器会将Node和MyNode变成下面这样： public class Node { public Object data; public Node(Object data) { this.data = data; } public void setData(Object data) { System.out.println(\"Node.setData\"); this.data = data; } } public class MyNode extends Node { public MyNode(Integer data) { super(data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } } ​ 实际上不是这样的，我们先来看一下下面这段代码，这段代码运行的时候会抛出ClassCastException异常，提示String无法转换成Integer： MyNode mn = new MyNode(5); Node n = mn; // A raw type - compiler throws an unchecked warning n.setData(\"Hello\"); // Causes a ClassCastException to be thrown. // Integer x = mn.data; ​ 如果按照我们上面生成的代码，运行到第3行的时候不应该报错(注意我注释掉了第4行)，因为MyNode中不存在setData(String data)方法，所以只能调用父类Node的setData(Object data)方法，既然这样上面的第3行代码不应该报错，因为String当然可以转换成Object了，那ClassCastException到底是怎么抛出的？ ​ 实际上Java编译器对上面代码自动还做了一个处理： class MyNode extends Node { // Bridge method generated by the compiler public void setData(Object data) { setData((Integer) data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } // ... } ​ 这也就是为什么上面会报错的原因了，setData((Integer) data);的时候String无法转换成Integer。所以上面第2行编译器提示unchecked warning的时候，我们不能选择忽略，不然要等到运行期间才能发现异常。如果我们一开始加上Node n = mn就好了，这样编译器就可以提前帮我们发现错误。 问题三(不能用类型参数创建实例) ​ 正如我们上面提到的，Java泛型很大程度上只能提供静态类型检查，然后类型的信息就会被擦除，所以像下面这样利用类型参数创建实例的做法编译器不会通过： public static void append(List list) { E elem = new E(); // compile-time error list.add(elem); } ​ 但是如果某些场景我们想要需要利用类型参数创建实例，我们应该怎么做呢？可以利用反射解决这个问题： public static void append(List list, Class cls) throws Exception { E elem = cls.newInstance(); // OK list.add(elem); } ​ 我们可以像下面这样调用： List ls = new ArrayList<>(); append(ls, String.class); ​ 实际上对于上面这个问题，还可以采用Factory和Template两种设计模式解决，感兴趣的朋友不妨去看一下Thinking in Java中第15章中关于Creating instance of types(英文版第664页)的讲解，这里我们就不深入了。 问题四(不能对泛型代码直接使用instanceof关键字) 我们无法对泛型代码直接使用instanceof关键字，因为Java编译器在生成代码的时候会擦除所有相关泛型的类型信息，正如我们上面验证过的JVM在运行时期无法识别出ArrayList和ArrayList的之间的区别： public static void rtti(List list) { if (list instanceof ArrayList) { // compile-time error // ... } } => { ArrayList, ArrayList, LinkedList, ... } ​ 和上面一样，我们可以使用通配符重新设置bounds来解决这个问题： public static void rtti(List list) { if (list instanceof ArrayList) { // OK; instanceof requires a reifiable type // ... } } 工厂模式 ​ 接下来我们利用泛型来简单的实现一下工厂模式，首先我们先声明一个接口Factory： package typeinfo.factory; public interface Factory { T create(); } ​ 接下来我们来创建几个实体类FuelFilter和AirFilter以及FanBelt和GeneratorBelt class Filter extends Part {} class FuelFilter extends Filter { public static class Factory implements typeinfo.factory.Factory { public FuelFilter create() { return new FuelFilter(); } } } class AirFilter extends Filter { public static class Factory implements typeinfo.factory.Factory { public AirFilter create() { return new AirFilter(); } } } class Belt extends Part {} class FanBelt extends Belt { public static class Factory implements typeinfo.factory.Factory { public FanBelt create() { return new FanBelt(); } } } class GeneratorBelt extends Belt { public static class Factory implements typeinfo.factory.Factory { public GeneratorBelt create() { return new GeneratorBelt(); } } } ​ Part类的实现如下，注意我们上面的实体类都是Part类的间接子类。在Part类我们注册了我们上面的声明的实体类。所以以后我们如果要创建相关的实体类的话，只需要在调用Part类的相关方法了。这么做的一个好处就是如果的业务中出现了CabinAirFilter或者PowerSteeringBelt的话，我们不需要修改太多的代码，只需要在Part类中将它们注册即可。 class Part { static List> partFactories = new ArrayList>(); static { partFactories.add(new FuelFilter.Factory()); partFactories.add(new AirFilter.Factory()); partFactories.add(new FanBelt.Factory()); partFactories.add(new PowerSteeringBelt.Factory()); } private static Random rand = new Random(47); public static Part createRandom() { int n = rand.nextInt(partFactories.size()); return partFactories.get(n).create(); } public String toString() { return getClass().getSimpleName(); } } ​ 最后我们来测试一下： public class RegisteredFactories { public static void main(String[] args) { for (int i = 0; i Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-02 21:25:10 "},"bean-convert.html":{"url":"bean-convert.html","title":"bean相互转换","keywords":"","body":"基于充血模式 import java.util.function.Supplier; import org.springframework.beans.BeanUtils; public interface BaseBean { public default T convert(Supplier supplier) { T t = supplier.get(); BeanUtils.copyProperties(this, t); return t; } } import java.util.function.Function; import java.util.function.Supplier; import org.springframework.beans.BeanUtils; import lombok.AllArgsConstructor; import lombok.Data; @Data @AllArgsConstructor public class UserVo implements BaseBean { private String username; private Integer password; // public T convert(Supplier supplier) { // T t = supplier.get(); // BeanUtils.copyProperties(this, t); // return t; // // } // public T convert(Function function) { // return function.apply(this); // // } // public T convert(Convent con) { // return con.apply(this); // // } // public T convert(UserVo userVo, Convent con) { // return con.apply(userVo); // // } } @Data public class UserBo { private String username; private Integer password; } public class DemoApplication { public static void main(String[] args) { UserVo userVo = new UserVo(\"wms\", 123456); UserBo userBo = userVo.convert(UserBo::new); // UserBo userBo = userVo.convert((s)->{ // UserBo uBo = new UserBo(); // BeanUtils.copyProperties(s, uBo); // return uBo; // }); System.out.println(userBo); } } bean 使我们使用最多的模型之一，我将以大篇幅去讲解 bean，希望读者好好体会。 domain 包名 根据很多 Java 程序员的”经验”来看，一个数据库表则对应着一个 domain 对象，所以很多程序员在写代码时，包名则使用：com.xxx.domain ，这样写好像已经成为了行业的一种约束，数据库映射对象就应该是 domain。但是你错了，domain 是一个领域对象，往往我们再做传统 Java 软件 Web 开发中，这些 domain 都是贫血模型，是没有行为的，或是没有足够的领域模型的行为的，所以，以这个理论来讲，这些 domain 都应该是一个普通的 entity 对象，并非领域对象，所以请把包名改为:com.xxx.entity。 如果你还不理解我说的话，请看一下 Vaughn Vernon 出的一本叫做《IMPLEMENTING DOMAIN-DRIVEN DESIGN》(实现领域驱动设计)这本书，书中讲解了贫血模型与领域模型的区别，相信你会受益匪浅。 DTO 数据传输我们应该使用 DTO 对象作为传输对象，这是我们所约定的，因为很长时间我一直都在做移动端 API 设计的工作，有很多人告诉我，他们认为只有给手机端传输数据的时候(input or output)，这些对象成为 DTO 对象。请注意！这种理解是错误的，只要是用于网络传输的对象，我们都认为他们可以当做是 DTO 对象，比如电商平台中，用户进行下单，下单后的数据，订单会发到 OMS 或者 ERP 系统，这些对接的返回值以及入参也叫 DTO 对象。 我们约定某对象如果是 DTO 对象，就将名称改为 XXDTO，比如订单下发OMS：OMSOrderInputDTO。 DTO 转化 正如我们所知，DTO 为系统与外界交互的模型对象，那么肯定会有一个步骤是将 DTO 对象转化为 BO 对象或者是普通的 entity 对象，让 service 层去处理。 场景 比如添加会员操作，由于用于演示，我只考虑用户的一些简单数据，当后台管理员点击添加用户时，只需要传过来用户的姓名和年龄就可以了，后端接受到数据后，将添加创建时间和更新时间和默认密码三个字段，然后保存数据库。 @RequestMapping(\"/v1/api/user\") @RestController public class UserApi { @Autowired private UserService userService; @PostMapping public User addUser(UserInputDTO userInputDTO){ User user = new User(); user.setUsername(userInputDTO.getUsername()); user.setAge(userInputDTO.getAge()); return userService.addUser(user); } } 我们只关注一下上述代码中的转化代码，其他内容请忽略： User user = new User(); user.setUsername(userInputDTO.getUsername()); user.setAge(userInputDTO.getAge()); 请使用工具 上边的代码，从逻辑上讲，是没有问题的，只是这种写法让我很厌烦，例子中只有两个字段，如果有 20 个字段，我们要如何做呢？ 一个一个进行 set 数据吗？当然，如果你这么做了，肯定不会有什么问题，但是，这肯定不是一个最优的做法。 网上有很多工具，支持浅拷贝或深拷贝的 Utils。举个例子，我们可以使用 org.springframework.beans.BeanUtils#copyProperties 对代码进行重构和优化： @PostMapping public User addUser(UserInputDTO userInputDTO){ User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return userService.addUser(user); } BeanUtils.copyProperties 是一个浅拷贝方法，复制属性时，我们只需要把 DTO 对象和要转化的对象两个的属性值设置为一样的名称，并且保证一样的类型就可以了。如果你在做 DTO 转化的时候一直使用 set 进行属性赋值，那么请尝试这种方式简化代码，让代码更加清晰! 转化的语义 上边的转化过程，读者看后肯定觉得优雅很多，但是我们再写 Java 代码时，更多的需要考虑语义的操作，再看上边的代码： User user = new User(); BeanUtils.copyProperties(userInputDTO,user); 虽然这段代码很好的简化和优化了代码，但是他的语义是有问题的，我们需要提现一个转化过程才好，所以代码改成如下： @PostMapping public User addUser(UserInputDTO userInputDTO){ User user = convertFor(userInputDTO); return userService.addUser(user); } private User convertFor(UserInputDTO userInputDTO){ User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } 这是一个更好的语义写法，虽然他麻烦了些，但是可读性大大增加了，在写代码时，我们应该尽量把语义层次差不多的放到一个方法中，比如： User user = convertFor(userInputDTO); return userService.addUser(user); 这两段代码都没有暴露实现，都是在讲如何在同一个方法中，做一组相同层次的语义操作，而不是暴露具体的实现。 如上所述，是一种重构方式，读者可以参考 Martin Fowler 的《Refactoring Imporving the Design of Existing Code》(重构 改善既有代码的设计) 这本书中的 Extract Method 重构方式。 抽象接口定义 当实际工作中，完成了几个 API 的 DTO 转化时，我们会发现，这样的操作有很多很多，那么应该定义好一个接口，让所有这样的操作都有规则的进行。 如果接口被定义以后，那么 convertFor 这个方法的语义将产生变化，它将是一个实现类。 看一下抽象后的接口： public interface DTOConvert { T convert(S s); } 虽然这个接口很简单，但是这里告诉我们一个事情，要去使用泛型，如果你是一个优秀的 Java 程序员，请为你想做的抽象接口，做好泛型吧。 我们再来看接口实现： public class UserInputDTOConvert implements DTOConvert { @Override public User convert(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } } 我们这样重构后，我们发现现在的代码是如此的简洁，并且那么的规范： @RequestMapping(\"/v1/api/user\") @RestController public class UserApi { @Autowired private UserService userService; @PostMapping public User addUser(UserInputDTO userInputDTO){ User user = new UserInputDTOConvert().convert(userInputDTO); return userService.addUser(user); } } review code 如果你是一个优秀的 Java 程序员，我相信你应该和我一样，已经数次重复 review 过自己的代码很多次了。 我们再看这个保存用户的例子，你将发现，API 中返回值是有些问题的，问题就在于不应该直接返回 User 实体，因为如果这样的话，就暴露了太多实体相关的信息，这样的返回值是不安全的，所以我们更应该返回一个 DTO 对象，我们可称它为 UserOutputDTO： @PostMapping public UserOutputDTO addUser(UserInputDTO userInputDTO){ User user = new UserInputDTOConvert().convert(userInputDTO); User saveUserResult = userService.addUser(user); UserOutputDTO result = new UserOutDTOConvert().convertToUser(saveUserResult); return result; } 这样你的 API 才更健全。 不知道在看完这段代码之后，读者有是否发现还有其他问题的存在，作为一个优秀的 Java 程序员，请看一下这段我们刚刚抽象完的代码: User user = new UserInputDTOConvert().convert(userInputDTO); 你会发现，new 这样一个 DTO 转化对象是没有必要的，而且每一个转化对象都是由在遇到 DTO 转化的时候才会出现，那我们应该考虑一下，是否可以将这个类和 DTO 进行聚合呢，看一下我的聚合结果: public class UserInputDTO { private String username; private int age; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public User convertToUser(){ UserInputDTOConvert userInputDTOConvert = new UserInputDTOConvert(); User convert = userInputDTOConvert.convert(this); return convert; } private static class UserInputDTOConvert implements DTOConvert { @Override public User convert(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } } } 然后 API 中的转化则由： User user = new UserInputDTOConvert().convert(userInputDTO); User saveUserResult = userService.addUser(user); 变成了： User user = userInputDTO.convertToUser(); User saveUserResult = userService.addUser(user); 我们再 DTO 对象中添加了转化的行为，我相信这样的操作可以让代码的可读性变得更强，并且是符合语义的。 再查工具类 再来看 DTO 内部转化的代码，它实现了我们自己定义的 DTOConvert 接口，但是这样真的就没有问题，不需要再思考了吗？ 我觉得并不是，对于 Convert 这种转化语义来讲，很多工具类中都有这样的定义，这中 Convert 并不是业务级别上的接口定义，它只是用于普通 bean 之间转化属性值的普通意义上的接口定义，所以我们应该更多的去读其他含有 Convert 转化语义的代码。 我仔细阅读了一下 GUAVA 的源码，发现了 com.google.common.base.Convert 这样的定义： public abstract class Converter implements Function { protected abstract B doForward(A a); protected abstract A doBackward(B b); //其他略 } 从源码可以了解到，GUAVA 中的 Convert 可以完成正向转化和逆向转化，继续修改我们 DTO 中转化的这段代码： private static class UserInputDTOConvert implements DTOConvert { @Override public User convert(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } } 修改后： private static class UserInputDTOConvert extends Converter { @Override protected User doForward(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } @Override protected UserInputDTO doBackward(User user) { UserInputDTO userInputDTO = new UserInputDTO(); BeanUtils.copyProperties(user,userInputDTO); return userInputDTO; } } 看了这部分代码以后，你可能会问，那逆向转化会有什么用呢？其实我们有很多小的业务需求中，入参和出参是一样的，那么我们变可以轻松的进行转化，我将上边所提到的 UserInputDTO 和 UserOutputDTO 都转成 UserDTO 展示给大家。 DTO： public class UserDTO { private String username; private int age; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public User convertToUser(){ UserDTOConvert userDTOConvert = new UserDTOConvert(); User convert = userDTOConvert.convert(this); return convert; } public UserDTO convertFor(User user){ UserDTOConvert userDTOConvert = new UserDTOConvert(); UserDTO convert = userDTOConvert.reverse().convert(user); return convert; } private static class UserDTOConvert extends Converter { @Override protected User doForward(UserDTO userDTO) { User user = new User(); BeanUtils.copyProperties(userDTO,user); return user; } @Override protected UserDTO doBackward(User user) { UserDTO userDTO = new UserDTO(); BeanUtils.copyProperties(user,userDTO); return userDTO; } } } API： @PostMapping public UserDTO addUser(UserDTO userDTO){ User user = userDTO.convertToUser(); User saveResultUser = userService.addUser(user); UserDTO result = userDTO.convertFor(saveResultUser); return result; } 当然，上述只是表明了转化方向的正向或逆向，很多业务需求的出参和入参的 DTO 对象是不同的，那么你需要更明显的告诉程序：逆向是无法调用的： private static class UserDTOConvert extends Converter { @Override protected User doForward(UserDTO userDTO) { User user = new User(); BeanUtils.copyProperties(userDTO,user); return user; } @Override protected UserDTO doBackward(User user) { throw new AssertionError(\"不支持逆向转化方法!\"); } } 看一下 doBackward 方法，直接抛出了一个断言异常，而不是业务异常，这段代码告诉代码的调用者，这个方法不是准你调用的，如果你调用，我就”断言”你调用错误了。 Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-02 21:28:44 "}}