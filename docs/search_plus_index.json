{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction gitbook install gitbook build ./ ./docs --clean gitp Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-02 22:02:27 "},"map-foreach.html":{"url":"map-foreach.html","title":"map遍历","keywords":"","body":"Java中遍历Map的几种方法 keySet values 如果只需要map的key或者value，用map的keySet或values方法无疑是最方便的 for (String key : map.keySet()) { System.out.println(key); } keySet get(key) 如果需要同时获取key和value，可以先获取key,然后再通过map的get(key)获取value 需要说明的是，该方法不是最优选择，一般不推荐使用 for (String key : map.keySet()) { System.out.println(key); System.out.println(map.get(key)); } entrySet 通过对map entrySet的遍历，也可以同时拿到key和value，一般情况下，性能上要优于上一种,这一种也是最常用的遍历方法 for (Map.Entry entry : map.entrySet()) { System.out.println(entry.getKey()); System.out.println(entry.getValue()); } Iterator 对于上面的几种foreach都可以用Iterator代替，其实foreach在java5中才被支持，foreach的写法看起来更简洁 但Iterator也有其优势：在用foreach遍历map时，如果改变其大小，会报错，但如果只是删除元素，可以使用Iterator的remove方法删除元素 Iterator> iterator = map.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry entry = iterator.next(); System.out.println(entry.getKey()); System.out.println(entry.getValue()); iterator.remove();//删除元素 } Lambda java8提供了Lambda表达式支持，语法看起来更简洁，可以同时拿到key和value，不过，经测试，性能低于entrySet,所以更推荐用entrySet的方式 map.forEach((key,value)->{ System.out.println(key); System.out.println(value); }); 总结 如果只是获取key，或者value，推荐使用keySet或者values方式 如果同时需要key和value推荐使用entrySet 如果需要在遍历过程中删除元素推荐使用Iterator 如果需要在遍历过程中增加元素，可以新建一个临时map存放新增的元素，等遍历完毕，再把临时map放到原来的map中 Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-02 21:09:07 "},"regex.html":{"url":"regex.html","title":"正则表达式","keywords":"","body":"正则表达式，一个十分古老而又强大的文本处理工具，仅仅用一段非常简短的表达式语句，便能够快速实现一个非常复杂的业务逻辑。熟练地掌握正则表达式的话，能够使你的开发效率得到极大的提升。 正则表达式经常被用于字段或任意字符串的校验，如下面这段校验基本日期格式的JavaScript代码： var reg = /^(\\\\d{1,4})(-|\\\\/)(\\\\d{1,2})\\\\2(\\\\d{1,2})$/; var r = fieldValue.match(reg); if(r==null)alert('Date format error!'); 下面是技匠整理的，在前端开发中经常使用到的20个正则表达式。 1 . 校验密码强度 密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。 ^(?=.*\\\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 2. 校验中文 字符串仅能是中文。 ^[\\\\\\u4e00-\\\\\\u9fa5]{0,}$ 3. 由数字、26个英文字母或下划线组成的字符串 ^\\\\w+$ 4. 校验E-Mail 地址 同密码一样，下面是E-mail地址合规性的正则检查语句。 [\\\\w!#$%&'*+/=?^_`{|}~-]+(?:\\\\.[\\\\w!#$%&'*+/=?^_`{|}~-]+)*@(?:[\\\\w](?:[\\\\w-]*[\\\\w])?\\\\.)+[\\\\w](?:[\\\\w-]*[\\\\w])? 5. 校验身份证号码 下面是身份证号码的正则校验。15 或 18位。 15位： ^[1-9]\\\\d{7}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}$ 18位： ^[1-9]\\\\d{5}[1-9]\\\\d{3}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}([0-9]|X)$ 6. 校验日期 “yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。 ^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$ 7. 校验金额 金额校验，精确到2位小数。 ^[0-9]+(.[0-9]{2})?$ 8. 校验手机号 下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码） ^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\\\d{8}$ 9. 判断IE的版本 IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。 ^.*MSIE [5-8](?:\\\\.[0-9]+)?(?!.*Trident\\\\/[5-9]\\\\.0).*$ 10. 校验IP-v4地址 IP4 正则语句。 \\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b 11. 校验IP-v6地址 IP6 正则语句。 (([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 12. 检查URL的前缀 应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。 if (!s.match(/^[a-zA-Z]+:\\\\/\\\\//)) { s = 'http://' + s; } 13. 提取URL链接 下面的这个表达式可以筛选出一段文本中的URL。 ^(f|ht){1}(tp|tps):\\\\/\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%&=]*)? 14. 文件路径及扩展名校验 验证windows下文件路径和扩展名（下面的例子中为.txt文件） ^([a-zA-Z]\\\\:|\\\\\\\\)\\\\\\\\([^\\\\\\\\]+\\\\\\\\)*[^\\\\/:*?\"<>|]+\\\\.txt(l)?$ 15. 提取Color Hex Codes 有时需要抽取网页中的颜色代码，可以使用下面的表达式。 ^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ 16. 提取网页图片 假若你想提取网页中所有图片信息，可以利用下面的表达式。 \\\\]*[src] *= *[\\\\\"\\\\']{0,1}([^\\\\\"\\\\'\\\\ >]*) 17. 提取页面超链接 提取html中的超链接。 (]*)(href=\"https?:\\\\/\\\\/)((?!(?:(?:www\\\\.)?'.implode('|(?:www\\\\.)?', $follow_list).'))[^\"]+)\"((?!.*\\\\brel=)[^>]*)(?:[^>]*)> 18. 查找CSS属性 通过下面的表达式，可以搜索到相匹配的CSS属性。 ^\\\\s*[a-zA-Z\\\\-]+\\\\s*[:]{1}\\\\s[a-zA-Z0-9\\\\s.#]+[;]{1} 19. 抽取注释 如果你需要移除HMTL中的注释，可以使用如下的表达式。 20. 匹配HTML标签 通过下面的表达式可以匹配出HTML中的标签属性。 \\\\s]+))?)+\\\\s*|\\\\s*)\\\\/?> Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-02 21:09:07 "},"java-generic.html":{"url":"java-generic.html","title":"泛型详解","keywords":"","body":" 引言 ​ 泛型是Java中一个非常重要的知识点，在Java集合类框架中泛型被广泛应用。本文我们将从零开始来看一下Java泛型的设计，将会涉及到通配符处理，以及让人苦恼的类型擦除。 泛型基础 泛型类 ​ 我们首先定义一个简单的Box类： public class Box { private String object; public void set(String object) { this.object = object; } public String get() { return object; } } ​ 这是最常见的做法，这样做的一个坏处是Box里面现在只能装入String类型的元素，今后如果我们需要装入Integer等其他类型的元素，还必须要另外重写一个Box，代码得不到复用，使用泛型可以很好的解决这个问题。 public class Box { // T stands for \"Type\" private T t; public void set(T t) { this.t = t; } public T get() { return t; } } ​ 这样我们的Box类便可以得到复用，我们可以将T替换成任何我们想要的类型： Box integerBox = new Box(); Box doubleBox = new Box(); Box stringBox = new Box(); 泛型方法 ​ 看完了泛型类，接下来我们来了解一下泛型方法。声明一个泛型方法很简单，只要在返回类型前面加上一个类似的形式就行了： public class Util { public static boolean compare(Pair p1, Pair p2) { return p1.getKey().equals(p2.getKey()) && p1.getValue().equals(p2.getValue()); } } public class Pair { private K key; private V value; public Pair(K key, V value) { this.key = key; this.value = value; } public void setKey(K key) { this.key = key; } public void setValue(V value) { this.value = value; } public K getKey() { return key; } public V getValue() { return value; } } ​ 我们可以像下面这样去调用泛型方法： Pair p1 = new Pair<>(1, \"apple\"); Pair p2 = new Pair<>(2, \"pear\"); boolean same = Util.compare(p1, p2); ​ 或者在Java1.7/1.8利用type inference，让Java自动推导出相应的类型参数： Pair p1 = new Pair<>(1, \"apple\"); Pair p2 = new Pair<>(2, \"pear\"); boolean same = Util.compare(p1, p2); 边界符:extends ​ 现在我们要实现这样一个功能，查找一个泛型数组中大于某个特定元素的个数，我们可以这样实现： public static int countGreaterThan(T[] anArray, T elem) { int count = 0; for (T e : anArray) if (e > elem) // compiler error ++count; return count; } ​ 但是这样很明显是错误的，因为除了short, int, double, long, float, byte, char等原始类型，其他的类并不一定能使用操作符>，所以编译器报错，那怎么解决这个问题呢？答案是使用边界符。 public interface Comparable { public int compareTo(T o); } ​ 做一个类似于下面这样的声明，这样就等于告诉编译器类型参数T代表的都是实现了Comparable接口的类，这样等于告诉编译器它们都至少实现了compareTo方法。 public static > int countGreaterThan(T[] anArray, T elem) { int count = 0; for (T e : anArray) if (e.compareTo(elem) > 0) ++count; return count; } 通配符: ? ​ 在了解通配符之前，我们首先必须要澄清一个概念，还是借用我们上面定义的Box类，假设我们添加一个这样的方法： public void boxTest(Box n) { /* ... */ } ​ 那么现在Box n允许接受什么类型的参数？我们是否能够传入Box或者Box呢？答案是否定的，虽然Integer和Double是Number的子类，但是在泛型中Box或者Box与Box之间并没有任何的关系。这一点非常重要，接下来我们通过一个完整的例子来加深一下理解。 ​ 首先我们先定义几个简单的类，下面我们将用到它： class Fruit {} class Apple extends Fruit {} class Orange extends Fruit {} ​ 下面这个例子中，我们创建了一个泛型类Reader，然后在f1()中当我们尝试Fruit f = fruitReader.readExact(apples);编译器会报错，因为List与List之间并没有任何的关系。 public class GenericReading { static List apples = Arrays.asList(new Apple()); static List fruit = Arrays.asList(new Fruit()); static class Reader { T readExact(List list) { return list.get(0); } } static void f1() { Reader fruitReader = new Reader(); // Errors: List cannot be applied to List. Fruit f = fruitReader.readExact(apples); } public static void main(String[] args) { f1(); } } ​ 但是按照我们通常的思维习惯，Apple和Fruit之间肯定是存在联系，然而编译器却无法识别，那怎么在泛型代码中解决这个问题呢？我们可以通过使用通配符来解决这个问题： static class CovariantReader { T readCovariant(List list) { return list.get(0); } } static void f2() { CovariantReader fruitReader = new CovariantReader(); Fruit f = fruitReader.readCovariant(fruit); Fruit a = fruitReader.readCovariant(apples); } public static void main(String[] args) { f2(); } ​ 这样就相当与告诉编译器， fruitReader的readCovariant方法接受的参数只要是满足Fruit的子类就行(包括Fruit自身)，这样子类和父类之间的关系也就关联上了。 PECS原则: super ​ 上面我们看到了类似的用法，利用它我们可以从list里面get元素，那么我们可不可以往list里面add元素呢？我们来尝试一下： public class GenericsAndCovariance { public static void main(String[] args) { // Wildcards allow covariance: List flist = new ArrayList(); // Compile Error: can't add any type of object: // flist.add(new Apple()) // flist.add(new Orange()) // flist.add(new Fruit()) // flist.add(new Object()) flist.add(null); // Legal but uninteresting // We Know that it returns at least Fruit: Fruit f = flist.get(0); } } ​ 答案是否定，Java编译器不允许我们这样做，为什么呢？对于这个问题我们不妨从编译器的角度去考虑。因为List flist它自身可以有多种含义： List flist = new ArrayList(); List flist = new ArrayList(); List flist = new ArrayList(); ​ 当我们尝试add一个Apple的时候，flist可能指向new ArrayList(); ​ 当我们尝试add一个Orange的时候，flist可能指向new ArrayList(); ​ 当我们尝试add一个Fruit的时候，这个Fruit可以是任何类型的Fruit，而flist可能只想某种特定类型的Fruit，编译器无法识别所以会报错。 所以对于实现了的集合类只能将它视为Producer向外提供(get)元素，而不能作为Consumer来对外获取(add)元素。 ​ 如果我们要add元素应该怎么做呢？可以使用： public class GenericWriting { static List apples = new ArrayList(); static List fruit = new ArrayList(); static void writeExact(List list, T item) { list.add(item); } static void f1() { writeExact(apples, new Apple()); writeExact(fruit, new Apple()); } static void writeWithWildcard(List list, T item) { list.add(item) } static void f2() { writeWithWildcard(apples, new Apple()); writeWithWildcard(fruit, new Apple()); } public static void main(String[] args) { f1(); f2(); } } ​ 这样我们可以往容器里面添加元素了，但是使用super的坏处是以后不能get容器里面的元素了，原因很简单，我们继续从编译器的角度考虑这个问题，对于List list，它可以有下面几种含义： List list = new ArrayList(); List list = new ArrayList(); List list = new ArrayList(); ​ 当我们尝试通过list来get一个Apple的时候，可能会get得到一个Fruit，这个Fruit可以是Orange等其他类型的Fruit。 根据上面的例子，我们可以总结出一条规律，”Producer Extends, Consumer Super”： ​ “Producer Extends” – 如果你需要一个只读List，用它来produce T，那么使用? extends T。 ​ “Consumer Super” – 如果你需要一个只写List，用它来consume T，那么使用? super T。 ​ 如果需要同时读取以及写入，那么我们就不能使用通配符了。 ​ 如何阅读过一些Java集合类的源码，可以发现通常我们会将两者结合起来一起用，比如像下面这样： public class Collections { public static void copy(List dest, List src) { for (int i=0; i 类型擦除 ​ Java泛型中最令人苦恼的地方或许就是类型擦除了，特别是对于有C++经验的程序员。类型擦除就是说Java泛型只能用于在编译期间的静态类型检查，然后编译器生成的代码会擦除相应的类型信息，这样到了运行期间实际上JVM根本就知道泛型所代表的具体类型。这样做的目的是因为Java泛型是1.5之后才被引入的，为了保持向下的兼容性，所以只能做类型擦除来兼容以前的非泛型代码。对于这一点，如果阅读Java集合框架的源码，可以发现有些类其实并不支持泛型。 ​ 说了这么多，那么泛型擦除到底是什么意思呢？我们先来看一下下面这个简单的例子： public class Node { private T data; private Node next; public Node(T data, Node next) { this.data = data; this.next = next; } public T getData() { return data; } // ... } ​ 编译器做完相应的类型检查之后，实际上到了运行期间上面这段代码实际上将转换成： public class Node { private Object data; private Node next; public Node(Object data, Node next) { this.data = data; this.next = next; } public Object getData() { return data; } // ... } ​ 这意味着不管我们声明Node还是Node，到了运行期间，JVM统统视为Node。有没有什么办法可以解决这个问题呢？这就需要我们自己重新设置bounds了，将上面的代码修改成下面这样： public class Node> { private T data; private Node next; public Node(T data, Node next) { this.data = data; this.next = next; } public T getData() { return data; } // ... } ​ 这样编译器就会将T出现的地方替换成Comparable而不再是默认的Object了： public class Node { private Comparable data; private Node next; public Node(Comparable data, Node next) { this.data = data; this.next = next; } public Comparable getData() { return data; } // ... } ​ 上面的概念或许还是比较好理解，但其实泛型擦除带来的问题远远不止这些，接下来我们系统地来看一下类型擦除所带来的一些问题，有些问题在C++的泛型中可能不会遇见，但是在Java中却需要格外小心。 问题一(不能创建泛型数组对象) 在Java中不允许创建泛型数组，类似下面这样的做法编译器会报错： List[] arrayOfLists = new List[2]; // compile-time error ​ 为什么编译器不支持上面这样的做法呢？继续使用逆向思维，我们站在编译器的角度来考虑这个问题。 ​ 我们先来看一下下面这个例子： Object[] strings = new String[2]; strings[0] = \"hi\"; // OK strings[1] = 100; // An ArrayStoreException is thrown. ​ 对于上面这段代码还是很好理解，字符串数组不能存放整型元素，而且这样的错误往往要等到代码运行的时候才能发现，编译器是无法识别的。接下来我们再来看一下假设Java支持泛型数组的创建会出现什么后果： Object[] stringLists = new List[]; // compiler error, but pretend it's allowed stringLists[0] = new ArrayList(); // OK // An ArrayStoreException should be thrown, but the runtime can't detect it. stringLists[1] = new ArrayList(); ​ 假设我们支持泛型数组的创建，由于运行时期类型信息已经被擦除，JVM实际上根本就不知道new ArrayList()和new ArrayList()的区别。类似这样的错误假如出现才实际的应用场景中，将非常难以察觉。 ​ 如果你对上面这一点还抱有怀疑的话，可以尝试运行下面这段代码： public class ErasedTypeEquivalence { public static void main(String[] args) { Class c1 = new ArrayList().getClass(); Class c2 = new ArrayList().getClass(); System.out.println(c1 == c2); // true } } 问题二(调用父类泛型方法的时候有个类型转换) ​ 继续复用我们上面的Node的类，对于泛型代码，Java编译器实际上还会偷偷帮我们实现一个Bridge method。 public class Node { public T data; public Node(T data) { this.data = data; } public void setData(T data) { System.out.println(\"Node.setData\"); this.data = data; } } public class MyNode extends Node { public MyNode(Integer data) { super(data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } } ​ 看完上面的分析之后，你可能会认为在类型擦除后，编译器会将Node和MyNode变成下面这样： public class Node { public Object data; public Node(Object data) { this.data = data; } public void setData(Object data) { System.out.println(\"Node.setData\"); this.data = data; } } public class MyNode extends Node { public MyNode(Integer data) { super(data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } } ​ 实际上不是这样的，我们先来看一下下面这段代码，这段代码运行的时候会抛出ClassCastException异常，提示String无法转换成Integer： MyNode mn = new MyNode(5); Node n = mn; // A raw type - compiler throws an unchecked warning n.setData(\"Hello\"); // Causes a ClassCastException to be thrown. // Integer x = mn.data; ​ 如果按照我们上面生成的代码，运行到第3行的时候不应该报错(注意我注释掉了第4行)，因为MyNode中不存在setData(String data)方法，所以只能调用父类Node的setData(Object data)方法，既然这样上面的第3行代码不应该报错，因为String当然可以转换成Object了，那ClassCastException到底是怎么抛出的？ ​ 实际上Java编译器对上面代码自动还做了一个处理： class MyNode extends Node { // Bridge method generated by the compiler public void setData(Object data) { setData((Integer) data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } // ... } ​ 这也就是为什么上面会报错的原因了，setData((Integer) data);的时候String无法转换成Integer。所以上面第2行编译器提示unchecked warning的时候，我们不能选择忽略，不然要等到运行期间才能发现异常。如果我们一开始加上Node n = mn就好了，这样编译器就可以提前帮我们发现错误。 问题三(不能用类型参数创建实例) ​ 正如我们上面提到的，Java泛型很大程度上只能提供静态类型检查，然后类型的信息就会被擦除，所以像下面这样利用类型参数创建实例的做法编译器不会通过： public static void append(List list) { E elem = new E(); // compile-time error list.add(elem); } ​ 但是如果某些场景我们想要需要利用类型参数创建实例，我们应该怎么做呢？可以利用反射解决这个问题： public static void append(List list, Class cls) throws Exception { E elem = cls.newInstance(); // OK list.add(elem); } ​ 我们可以像下面这样调用： List ls = new ArrayList<>(); append(ls, String.class); ​ 实际上对于上面这个问题，还可以采用Factory和Template两种设计模式解决，感兴趣的朋友不妨去看一下Thinking in Java中第15章中关于Creating instance of types(英文版第664页)的讲解，这里我们就不深入了。 问题四(不能对泛型代码直接使用instanceof关键字) 我们无法对泛型代码直接使用instanceof关键字，因为Java编译器在生成代码的时候会擦除所有相关泛型的类型信息，正如我们上面验证过的JVM在运行时期无法识别出ArrayList和ArrayList的之间的区别： public static void rtti(List list) { if (list instanceof ArrayList) { // compile-time error // ... } } => { ArrayList, ArrayList, LinkedList, ... } ​ 和上面一样，我们可以使用通配符重新设置bounds来解决这个问题： public static void rtti(List list) { if (list instanceof ArrayList) { // OK; instanceof requires a reifiable type // ... } } 工厂模式 ​ 接下来我们利用泛型来简单的实现一下工厂模式，首先我们先声明一个接口Factory： package typeinfo.factory; public interface Factory { T create(); } ​ 接下来我们来创建几个实体类FuelFilter和AirFilter以及FanBelt和GeneratorBelt class Filter extends Part {} class FuelFilter extends Filter { public static class Factory implements typeinfo.factory.Factory { public FuelFilter create() { return new FuelFilter(); } } } class AirFilter extends Filter { public static class Factory implements typeinfo.factory.Factory { public AirFilter create() { return new AirFilter(); } } } class Belt extends Part {} class FanBelt extends Belt { public static class Factory implements typeinfo.factory.Factory { public FanBelt create() { return new FanBelt(); } } } class GeneratorBelt extends Belt { public static class Factory implements typeinfo.factory.Factory { public GeneratorBelt create() { return new GeneratorBelt(); } } } ​ Part类的实现如下，注意我们上面的实体类都是Part类的间接子类。在Part类我们注册了我们上面的声明的实体类。所以以后我们如果要创建相关的实体类的话，只需要在调用Part类的相关方法了。这么做的一个好处就是如果的业务中出现了CabinAirFilter或者PowerSteeringBelt的话，我们不需要修改太多的代码，只需要在Part类中将它们注册即可。 class Part { static List> partFactories = new ArrayList>(); static { partFactories.add(new FuelFilter.Factory()); partFactories.add(new AirFilter.Factory()); partFactories.add(new FanBelt.Factory()); partFactories.add(new PowerSteeringBelt.Factory()); } private static Random rand = new Random(47); public static Part createRandom() { int n = rand.nextInt(partFactories.size()); return partFactories.get(n).create(); } public String toString() { return getClass().getSimpleName(); } } ​ 最后我们来测试一下： public class RegisteredFactories { public static void main(String[] args) { for (int i = 0; i Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-02 21:25:10 "},"bean-convert.html":{"url":"bean-convert.html","title":"bean相互转换","keywords":"","body":"基于充血模式 import java.util.function.Supplier; import org.springframework.beans.BeanUtils; public interface BaseBean { public default T convert(Supplier supplier) { T t = supplier.get(); BeanUtils.copyProperties(this, t); return t; } } import java.util.function.Function; import java.util.function.Supplier; import org.springframework.beans.BeanUtils; import lombok.AllArgsConstructor; import lombok.Data; @Data @AllArgsConstructor public class UserVo implements BaseBean { private String username; private Integer password; // public T convert(Supplier supplier) { // T t = supplier.get(); // BeanUtils.copyProperties(this, t); // return t; // // } // public T convert(Function function) { // return function.apply(this); // // } // public T convert(Convent con) { // return con.apply(this); // // } // public T convert(UserVo userVo, Convent con) { // return con.apply(userVo); // // } } @Data public class UserBo { private String username; private Integer password; } public class DemoApplication { public static void main(String[] args) { UserVo userVo = new UserVo(\"wms\", 123456); UserBo userBo = userVo.convert(UserBo::new); // UserBo userBo = userVo.convert((s)->{ // UserBo uBo = new UserBo(); // BeanUtils.copyProperties(s, uBo); // return uBo; // }); System.out.println(userBo); } } bean 使我们使用最多的模型之一，我将以大篇幅去讲解 bean，希望读者好好体会。 domain 包名 根据很多 Java 程序员的”经验”来看，一个数据库表则对应着一个 domain 对象，所以很多程序员在写代码时，包名则使用：com.xxx.domain ，这样写好像已经成为了行业的一种约束，数据库映射对象就应该是 domain。但是你错了，domain 是一个领域对象，往往我们再做传统 Java 软件 Web 开发中，这些 domain 都是贫血模型，是没有行为的，或是没有足够的领域模型的行为的，所以，以这个理论来讲，这些 domain 都应该是一个普通的 entity 对象，并非领域对象，所以请把包名改为:com.xxx.entity。 如果你还不理解我说的话，请看一下 Vaughn Vernon 出的一本叫做《IMPLEMENTING DOMAIN-DRIVEN DESIGN》(实现领域驱动设计)这本书，书中讲解了贫血模型与领域模型的区别，相信你会受益匪浅。 DTO 数据传输我们应该使用 DTO 对象作为传输对象，这是我们所约定的，因为很长时间我一直都在做移动端 API 设计的工作，有很多人告诉我，他们认为只有给手机端传输数据的时候(input or output)，这些对象成为 DTO 对象。请注意！这种理解是错误的，只要是用于网络传输的对象，我们都认为他们可以当做是 DTO 对象，比如电商平台中，用户进行下单，下单后的数据，订单会发到 OMS 或者 ERP 系统，这些对接的返回值以及入参也叫 DTO 对象。 我们约定某对象如果是 DTO 对象，就将名称改为 XXDTO，比如订单下发OMS：OMSOrderInputDTO。 DTO 转化 正如我们所知，DTO 为系统与外界交互的模型对象，那么肯定会有一个步骤是将 DTO 对象转化为 BO 对象或者是普通的 entity 对象，让 service 层去处理。 场景 比如添加会员操作，由于用于演示，我只考虑用户的一些简单数据，当后台管理员点击添加用户时，只需要传过来用户的姓名和年龄就可以了，后端接受到数据后，将添加创建时间和更新时间和默认密码三个字段，然后保存数据库。 @RequestMapping(\"/v1/api/user\") @RestController public class UserApi { @Autowired private UserService userService; @PostMapping public User addUser(UserInputDTO userInputDTO){ User user = new User(); user.setUsername(userInputDTO.getUsername()); user.setAge(userInputDTO.getAge()); return userService.addUser(user); } } 我们只关注一下上述代码中的转化代码，其他内容请忽略： User user = new User(); user.setUsername(userInputDTO.getUsername()); user.setAge(userInputDTO.getAge()); 请使用工具 上边的代码，从逻辑上讲，是没有问题的，只是这种写法让我很厌烦，例子中只有两个字段，如果有 20 个字段，我们要如何做呢？ 一个一个进行 set 数据吗？当然，如果你这么做了，肯定不会有什么问题，但是，这肯定不是一个最优的做法。 网上有很多工具，支持浅拷贝或深拷贝的 Utils。举个例子，我们可以使用 org.springframework.beans.BeanUtils#copyProperties 对代码进行重构和优化： @PostMapping public User addUser(UserInputDTO userInputDTO){ User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return userService.addUser(user); } BeanUtils.copyProperties 是一个浅拷贝方法，复制属性时，我们只需要把 DTO 对象和要转化的对象两个的属性值设置为一样的名称，并且保证一样的类型就可以了。如果你在做 DTO 转化的时候一直使用 set 进行属性赋值，那么请尝试这种方式简化代码，让代码更加清晰! 转化的语义 上边的转化过程，读者看后肯定觉得优雅很多，但是我们再写 Java 代码时，更多的需要考虑语义的操作，再看上边的代码： User user = new User(); BeanUtils.copyProperties(userInputDTO,user); 虽然这段代码很好的简化和优化了代码，但是他的语义是有问题的，我们需要提现一个转化过程才好，所以代码改成如下： @PostMapping public User addUser(UserInputDTO userInputDTO){ User user = convertFor(userInputDTO); return userService.addUser(user); } private User convertFor(UserInputDTO userInputDTO){ User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } 这是一个更好的语义写法，虽然他麻烦了些，但是可读性大大增加了，在写代码时，我们应该尽量把语义层次差不多的放到一个方法中，比如： User user = convertFor(userInputDTO); return userService.addUser(user); 这两段代码都没有暴露实现，都是在讲如何在同一个方法中，做一组相同层次的语义操作，而不是暴露具体的实现。 如上所述，是一种重构方式，读者可以参考 Martin Fowler 的《Refactoring Imporving the Design of Existing Code》(重构 改善既有代码的设计) 这本书中的 Extract Method 重构方式。 抽象接口定义 当实际工作中，完成了几个 API 的 DTO 转化时，我们会发现，这样的操作有很多很多，那么应该定义好一个接口，让所有这样的操作都有规则的进行。 如果接口被定义以后，那么 convertFor 这个方法的语义将产生变化，它将是一个实现类。 看一下抽象后的接口： public interface DTOConvert { T convert(S s); } 虽然这个接口很简单，但是这里告诉我们一个事情，要去使用泛型，如果你是一个优秀的 Java 程序员，请为你想做的抽象接口，做好泛型吧。 我们再来看接口实现： public class UserInputDTOConvert implements DTOConvert { @Override public User convert(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } } 我们这样重构后，我们发现现在的代码是如此的简洁，并且那么的规范： @RequestMapping(\"/v1/api/user\") @RestController public class UserApi { @Autowired private UserService userService; @PostMapping public User addUser(UserInputDTO userInputDTO){ User user = new UserInputDTOConvert().convert(userInputDTO); return userService.addUser(user); } } review code 如果你是一个优秀的 Java 程序员，我相信你应该和我一样，已经数次重复 review 过自己的代码很多次了。 我们再看这个保存用户的例子，你将发现，API 中返回值是有些问题的，问题就在于不应该直接返回 User 实体，因为如果这样的话，就暴露了太多实体相关的信息，这样的返回值是不安全的，所以我们更应该返回一个 DTO 对象，我们可称它为 UserOutputDTO： @PostMapping public UserOutputDTO addUser(UserInputDTO userInputDTO){ User user = new UserInputDTOConvert().convert(userInputDTO); User saveUserResult = userService.addUser(user); UserOutputDTO result = new UserOutDTOConvert().convertToUser(saveUserResult); return result; } 这样你的 API 才更健全。 不知道在看完这段代码之后，读者有是否发现还有其他问题的存在，作为一个优秀的 Java 程序员，请看一下这段我们刚刚抽象完的代码: User user = new UserInputDTOConvert().convert(userInputDTO); 你会发现，new 这样一个 DTO 转化对象是没有必要的，而且每一个转化对象都是由在遇到 DTO 转化的时候才会出现，那我们应该考虑一下，是否可以将这个类和 DTO 进行聚合呢，看一下我的聚合结果: public class UserInputDTO { private String username; private int age; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public User convertToUser(){ UserInputDTOConvert userInputDTOConvert = new UserInputDTOConvert(); User convert = userInputDTOConvert.convert(this); return convert; } private static class UserInputDTOConvert implements DTOConvert { @Override public User convert(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } } } 然后 API 中的转化则由： User user = new UserInputDTOConvert().convert(userInputDTO); User saveUserResult = userService.addUser(user); 变成了： User user = userInputDTO.convertToUser(); User saveUserResult = userService.addUser(user); 我们再 DTO 对象中添加了转化的行为，我相信这样的操作可以让代码的可读性变得更强，并且是符合语义的。 再查工具类 再来看 DTO 内部转化的代码，它实现了我们自己定义的 DTOConvert 接口，但是这样真的就没有问题，不需要再思考了吗？ 我觉得并不是，对于 Convert 这种转化语义来讲，很多工具类中都有这样的定义，这中 Convert 并不是业务级别上的接口定义，它只是用于普通 bean 之间转化属性值的普通意义上的接口定义，所以我们应该更多的去读其他含有 Convert 转化语义的代码。 我仔细阅读了一下 GUAVA 的源码，发现了 com.google.common.base.Convert 这样的定义： public abstract class Converter implements Function { protected abstract B doForward(A a); protected abstract A doBackward(B b); //其他略 } 从源码可以了解到，GUAVA 中的 Convert 可以完成正向转化和逆向转化，继续修改我们 DTO 中转化的这段代码： private static class UserInputDTOConvert implements DTOConvert { @Override public User convert(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } } 修改后： private static class UserInputDTOConvert extends Converter { @Override protected User doForward(UserInputDTO userInputDTO) { User user = new User(); BeanUtils.copyProperties(userInputDTO,user); return user; } @Override protected UserInputDTO doBackward(User user) { UserInputDTO userInputDTO = new UserInputDTO(); BeanUtils.copyProperties(user,userInputDTO); return userInputDTO; } } 看了这部分代码以后，你可能会问，那逆向转化会有什么用呢？其实我们有很多小的业务需求中，入参和出参是一样的，那么我们变可以轻松的进行转化，我将上边所提到的 UserInputDTO 和 UserOutputDTO 都转成 UserDTO 展示给大家。 DTO： public class UserDTO { private String username; private int age; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public User convertToUser(){ UserDTOConvert userDTOConvert = new UserDTOConvert(); User convert = userDTOConvert.convert(this); return convert; } public UserDTO convertFor(User user){ UserDTOConvert userDTOConvert = new UserDTOConvert(); UserDTO convert = userDTOConvert.reverse().convert(user); return convert; } private static class UserDTOConvert extends Converter { @Override protected User doForward(UserDTO userDTO) { User user = new User(); BeanUtils.copyProperties(userDTO,user); return user; } @Override protected UserDTO doBackward(User user) { UserDTO userDTO = new UserDTO(); BeanUtils.copyProperties(user,userDTO); return userDTO; } } } API： @PostMapping public UserDTO addUser(UserDTO userDTO){ User user = userDTO.convertToUser(); User saveResultUser = userService.addUser(user); UserDTO result = userDTO.convertFor(saveResultUser); return result; } 当然，上述只是表明了转化方向的正向或逆向，很多业务需求的出参和入参的 DTO 对象是不同的，那么你需要更明显的告诉程序：逆向是无法调用的： private static class UserDTOConvert extends Converter { @Override protected User doForward(UserDTO userDTO) { User user = new User(); BeanUtils.copyProperties(userDTO,user); return user; } @Override protected UserDTO doBackward(User user) { throw new AssertionError(\"不支持逆向转化方法!\"); } } 看一下 doBackward 方法，直接抛出了一个断言异常，而不是业务异常，这段代码告诉代码的调用者，这个方法不是准你调用的，如果你调用，我就”断言”你调用错误了。 Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-02 21:28:44 "},"stream.html":{"url":"stream.html","title":"java-8-stream操作","keywords":"","body":"Java Stream API 入门篇 代码简洁，函数式编程写出的代码简洁且意图明确，使用stream接口让你从此告别for循环。 多核友好，Java函数式编程使得编写并行程序从未如此简单，你需要的全部就是调用一下parallel()方法。 stream并不是某种数据结构，它只是数据源的一种视图。这里的数据源可以是一个数组，Java容器或I/O channel等。正因如此要得到一个stream通常不会手动创建，而是调用对应的工具方法，比如： 调用Collection.stream()或者Collection.parallelStream()方法； 调用Arrays.stream(T[] array)方法。 常见的stream接口继承关系如图： 为不同数据类型设置不同stream接口，可以1.提高性能，2.增加特定接口函数。 BaseStream |-- IntStream int类型 |-- LongStream long类型 |-- DoubleStream double类型 |-- Stream 其他类型 虽然大部分情况下stream是容器调用Collection.stream()方法得到的，但stream和collections有以下不同： 无存储。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。 为函数式编程而生。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。 惰式执行。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。 可消费性。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。 对stream的操作分为为两类，中间操作(intermediate operations)和结束操作(terminal operations)，二者特点是： 中间操作总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。 结束操作会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。 操作类型 接口方法 中间操作 无状态 concat() filter() flatMap() map() peek() parallel() sequentila() unordered() mapToInt() mapToLong() mapToDouble() flatMapToInt() 有状态 distinct() sorted() limit() skip() 结束操作 非短路 collect() count() forEach() forEachOrdered() max() min() reduce() toArray() 短路 allMatch() anyMatch() noneMatch() findFirst() fndAny() 区分中间操作和结束操作最简单的方法，就是看方法的返回值，返回值为stream的大都是中间操作，否则是结束操作。 stream方法使用 stream跟函数接口关系非常紧密，没有函数接口stream就无法工作。回顾一下：函数接口是指内部只有一个抽象方法的接口。通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字。 max()--最大元素 Optional max = stream.max((s1,s2)->s1.length()-s2.length()); String string = max.get(); findAny()--任一一元素 Optional optional = stream.filter(s->s.length()==1).findAny(); String string = optional.get(); anyMatch()--任一匹配 boolean allMatch = stream.anyMatch(s->s.length()==3); noneMatch()--无一匹配 stream.noneMatch(s->s.length()==3); allMatch()--全部匹配 stream.allMatch(s->s.length()==1); toArray()--转成数组 Object[] array = stream.toArray(); forEachOrdered()--遍历 并行流中仍然按照原顺序遍历 List list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8); list.stream().parallel().forEach(x -> System.out.print(x)); list.stream().parallel().forEachOrdered(x -> System.out.print(x)); skip()--去除前n个元素 Stream stream = Stream.of(\"1\", \"2\", \"3\", \"4\"); stream.skip(2)//截去前两个元素，只取后面的元素 .forEach(System.out::println); limit()--指定元素大小 Stream stream = Stream.of(\"1\", \"2\", \"3\", \"4\"); stream.limit(2l)//限制两个元素，只取前两个元素 .forEach(System.out::println); mapToInt()--元素转int Stream stream = Stream.of(\"1\", \"2\", \"3\", \"4\"); stream.mapToInt(Integer::parseInt).forEach(System.out::println); parallel()--并行流 流可以是顺序的也可以是并行的。顺序流的操作是在单线程上执行的，而并行流的操作是在多线程上并发执行的。 stream.parallel().forEach(System.out::println); peek()--遍历 对stream中的每一个元素进行遍历消费，返回一个新流 Stream peek(Consumer action); Stream stream = Stream.of(\"I\", \"love\", \"you\", \"too\"); stream.peek(TestM::getStr)//中间操作 .forEach(System.out::println);//结束操作 count()--元素个数 Stream stream = Stream.of(\"I\", \"love\", \"you\", \"too\"); long count = stream.count();//4个元素 forEach()--遍历 我们对forEach()方法并不陌生，在Collection中我们已经见过。方法签名为void forEach(Consumer action)，作用是对容器中的每个元素执行action指定的动作，也就是对元素进行遍历。 // 使用Stream.forEach()迭代 String[] arry = {\"I\", \"love\", \"you\", \"too\"}; Stream stream = Stream.of(arry); stream.forEach(str -> System.out.println(str)); filter()--过滤 函数原型为Stream filter(Predicate predicate)，作用是返回一个只包含满足predicate条件元素的Stream。 String[] arry = {\"I\", \"love\", \"you\", \"too\"}; Stream stream = Stream.of(arry); stream.filter(str->str.length()==3)//中间操作，过滤元素长度等于3的元素 .forEach(str -> System.out.println(str));//最终操作 distinct()--去重 函数原型为Stream distinct()，作用是返回一个去除重复元素之后的Stream String[] arry = {\"I\", \"love\", \"you\", \"too\",\"too\",\"you\"}; Stream stream = Stream.of(arry); stream.distinct()//中间操作,去除重复元素 .forEach(str -> System.out.println(str));//最终操作 sorted()--排序 排序函数有两个，一个是用自然顺序排序，一个是使用自定义比较器排序，函数原型分别为Stream　sorted()和Stream　sorted(Comparator comparator)。 Stream stream= Stream.of(\"I\", \"love\", \"you\", \"too\"); stream.sorted((str1, str2) -> str1.length()-str2.length())//中间操作，按元素长度排序 .forEach(str -> System.out.println(str));//最终操作，遍历打印 map()--转换 函数原型为 Stream map(Function mapper)，作用是返回一个对当前所有元素执行执行mapper之后的结果组成的Stream。直观的说，就是对每个元素按照某种操作进行转换，转换前后Stream中元素的个数不会改变，但元素的类型取决于转换之后的类型。 Stream stream = Stream.of(\"I\", \"love\", \"you\", \"too\"); stream.map(str -> str.toUpperCase())//转换成大写 .forEach(str -> System.out.println(str)); flatMap()--合并 函数原型为 Stream flatMap(Function> mapper)，作用是对每个元素执行mapper指定的操作，并用所有mapper返回的Stream中的元素组成一个新的Stream作为最终返回结果。说起来太拗口，通俗的讲flatMap()的作用就相当于把原stream中的所有元素都”摊平”之后组成的Stream，转换前后元素的个数和类型都可能会改变。 Stream> stream = Stream.of(Arrays.asList(1,2), Arrays.asList(3, 4, 5)); stream.flatMap(list -> list.stream())//转换到一个流 .forEach(i -> System.out.println(i)); Java Stream API 进阶篇 规约操作（reduction operation）又被称作折叠操作（fold），是通过某个连接动作将所有元素汇总成一个汇总结果的过程。元素求和、求最大值或最小值、求出元素总个数、将所有元素转换成一个列表或集合，都属于规约操作。Stream类库有两个通用的规约操作reduce()和collect()，也有一些为简化书写而设计的专用规约操作，比如sum()、max()、min()、count()等。 最大或最小值这类规约操作很好理解（至少方法语义上是这样），我们着重介绍reduce()和collect() reduce()--生成一个值 reduce操作可以实现从一组元素中生成一个值，sum()、max()、min()、count()等都是reduce操作，将他们单独设为函数只是因为常用。 reduce()的方法定义有三种重写形式： Optional reduce(BinaryOperator accumulator) T reduce(T identity, BinaryOperator accumulator) U reduce(U identity, BiFunction accumulator, BinaryOperator combiner) Optional reduce(BinaryOperator accumulator) 我们先看第一个变形，其接受一个函数接口BinaryOperator，而这个接口又继承于BiFunction BinaryOperator接口，可以看到reduce方法接受一个函数，这个函数有两个参数，第一个参数是上次函数执行的返回值（也称为中间结果），第二个参数是stream中的元素，这个函数把这两个值相加，得到的和会被赋值给下次执行这个函数的第一个参数。要注意的是：第一次执行的时候第一个参数的值是Stream的第一个元素，第二个参数是Stream的第二个元素 第一变形：未定义初始值，从而第一次执行的时候第一个参数的值是Stream的第一个元素，第二个参数是Stream的第二个元素 T reduce(T identity, BinaryOperator accumulator) 第二个变形，与第一种变形相同的是都会接受一个BinaryOperator函数接口，不同的是其会接受一个identity参数，用来指定Stream循环的初始值。定义了初始值，从而第一次执行的时候第一个参数的值是初始值，第二个参数是Stream的第一个元素。如果Stream为空，就直接返回该值。另一方面，该方法不会返回Optional，因为该方法不会出现null。 U reduce(U identity, BiFunction accumulator, BinaryOperator combiner) Stream是支持并发操作的，为了避免竞争，对于reduce线程都会有独立的result，combiner的作用在于合并每个线程的result得到最终结果。这也说明了了第三个函数参数的数据类型必须为返回数据类型了。 虽然函数定义越来越长，但语义不曾改变，多的参数只是为了指明初始值（参数identity），或者是指定并行执行时多个部分结果的合并方式（参数combiner）。reduce()最常用的场景就是从一堆值中生成一个值。用这么复杂的函数去求一个最大或最小值，你是不是觉得设计者有病。其实不然，因为“大”和“小”或者“求和”有时会有不同的语义。 Stream stream = Stream.of(\"I\", \"love\", \"you\", \"too\"); Optional longest = stream.reduce((s1, s2) -> s1.length()>=s2.length() ? s1 : s2); //Optional longest = stream.max((s1, s2) -> s1.length()-s2.length()); System.out.println(longest.get()); 上述代码会选出最长的单词love，其中Optional是（一个）值的容器，使用它可以避免null值的麻烦。当然可以使用Stream.max(Comparator comparator)方法来达到同等效果，但reduce()自有其存在的理由。 需求：求出一组单词的长度之和。这是个“求和”操作，操作对象输入类型是String，而结果类型是Integer。 // 求单词长度之和 Stream stream = Stream.of(\"I\", \"love\", \"you\", \"too\"); Integer lengthSum = stream.reduce(0,　// 初始值　// (1) (sum, str) -> sum+str.length(), // 累加器 // (2) (a, b) -> a+b);　// 部分和拼接器，并行执行时才会用到 // (3) // int lengthSum = stream.mapToInt(str -> str.length()).sum(); System.out.println(lengthSum); 上述代码标号(2)处将i. 字符串映射成长度，ii. 并和当前累加和相加。这显然是两步操作，使用reduce()函数将这两步合二为一，更有助于提升性能。如果想要使用map()和sum()组合来达到上述目的，也是可以的。 reduce()擅长的是生成一个值，如果想要从Stream生成一个集合或者Map等复杂的对象该怎么办呢？终极武器collect()横空出世！ collect()--生成一个集合 Stream -> collection 不夸张的讲，如果你发现某个功能在Stream接口中没找到，十有八九可以通过collect()方法实现。collect()是Stream接口方法中最灵活的一个，学会它才算真正入门Java函数式编程。先看几个热身的小例子： Stream stream = Stream.of(\"I\", \"love\", \"you\", \"too\"); List list = stream.collect(Collectors.toList()); // stream -> list Set set = stream.collect(Collectors.toSet()); // Stream -> set Map map = stream.collect(Collectors.toMap(Function.identity(), String::length)); // Stream -> map ArrayList arrayList = stream.collect(Collectors.toCollection(ArrayList::new));// Stream -> arrayList HashSet hashSet = stream.collect(Collectors.toCollection(HashSet::new));// Stream -> HashSet 上述代码分别列举了如何将Stream转换成List、Set和Map。虽然代码语义很明确，可是我们仍然会有几个疑问： Function.identity()是干什么的？ String::length是什么意思？ Collectors是个什么东西？收集器（Collector）是为Stream.collect()方法量身打造的工具接口（类） 接口的静态方法和默认方法 Function是一个接口，那么Function.identity()是什么意思呢？这要从两方面解释： Java 8允许在接口中加入具体方法。接口中的具体方法有两种，default方法和static方法，identity()就是Function接口的一个静态方法。 Function.identity()返回一个输出跟输入一样的Lambda表达式对象，等价于形如t -> t形式的Lambda表达式。 方法引用 诸如String::length的语法形式叫做方法引用（method references），这种语法用来替代某些特定形式Lambda表达式。如果Lambda表达式的全部内容就是调用一个已有的方法，那么可以用方法引用来替代Lambda表达式。方法引用可以细分为四类： 方法引用的类别 举例 引用静态方法 Integer::sum 应用对象方法 list::add 应用某个类的方法 String::length 应用构造方法 HashMap::new Stream -> map 前面已经说过Stream背后依赖于某种数据源，数据源可以是数组、容器等，但不能是Map。反过来从Stream生成Map是可以的，但我们要想清楚Map的key和value分别代表什么，根本原因是我们要想清楚要干什么。通常在三种情况下collect()的结果会是Map： 使用Collectors.toMap()生成的收集器，用户需要指定如何生成Map的key和value。 使用Collectors.partitioningBy()生成的收集器，对元素进行二分区操作时用到。 使用Collectors.groupingBy()生成的收集器，对元素做group操作时用到。 情况1：使用toMap()生成的收集器，这种情况是最直接的，前面例子中已提到，这是和Collectors.toCollection()并列的方法。如下代码展示将学生列表转换成由组成的Map。非常直观，无需多言。 // 使用toMap()统计学生GPA Map studentToGPA =students.stream().collect( Collectors.toMap(Functions.identity(),// 如何生成key student -> computeGPA(student)// 如何生成value ) ); 情况2：使用partitioningBy()生成的收集器，这种情况适用于将Stream中的元素依据某个二值逻辑（满足条件，或不满足）分成互补相交的两部分，比如男女性别、成绩及格与否等。下列代码展示将学生分成成绩及格或不及格的两部分。 // Partition students into passing and failing Map> passingFailing = students.stream() .collect(Collectors.partitioningBy(s -> s.getGrade() >= PASS_THRESHOLD)); 情况3：使用groupingBy()生成的收集器，这是比较灵活的一种情况。跟SQL中的group by语句类似，这里的groupingBy()也是按照某个属性对数据进行分组，属性相同的元素会被对应到Map的同一个key上。下列代码展示将员工按照部门进行分组： // Group employees by department Map> byDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment)); 以上只是分组的最基本用法，有些时候仅仅分组是不够的。在SQL中使用group by是为了协助其他查询，比如1. 先将员工按照部门分组，2. 然后统计每个部门员工的人数。Java类库设计者也考虑到了这种情况，增强版的groupingBy()能够满足这种需求。增强版的groupingBy()允许我们对元素分组之后再执行某种运算，比如求和、计数、平均值、类型转换等。这种先将元素分组的收集器叫做上游收集器，之后执行其他运算的收集器叫做下游收集器(downstream Collector)。 // 使用下游收集器统计每个部门的人数 Map totalByDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.counting()));// 下游收集器 上面代码的逻辑是不是越看越像SQL？高度非结构化。还有更狠的，下游收集器还可以包含更下游的收集器，这绝不是为了炫技而增加的把戏，而是实际场景需要。考虑将员工按照部门分组的场景，如果我们想得到每个员工的名字（字符串），而不是一个个Employee对象，可通过如下方式做到： // 按照部门对员工分布组，并只保留员工的名字 Map> byDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.mapping(Employee::getName,// 下游收集器 Collectors.toList())));// 更下游的收集器 拼接字符串 // 使用Collectors.joining()拼接字符串 Stream stream = Stream.of(\"I\", \"love\", \"you\"); //String joined = stream.collect(Collectors.joining());// \"Iloveyou\" //String joined = stream.collect(Collectors.joining(\",\"));// \"I,love,you\" String joined = stream.collect(Collectors.joining(\",\", \"{\", \"}\"));// \"{I,love,you}\" Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-03 18:35:17 "},"enum.html":{"url":"enum.html","title":"枚举","keywords":"","body":"枚举 import lombok.AllArgsConstructor; import lombok.Generated; import lombok.Getter; @AllArgsConstructor @Getter @Generated public enum DataTypeEnum { /** 视频 */ VIDEO(\"video\", \"视频\"), /** 图片 */ IMAGE(\"image\", \"图片\"), /** 文本 */ TXT(\"txt\", \"文本\"); private String dataType; private String desc; public static String getDesc(String dataType) { for (DataTypeEnum en : DataTypeEnum.values()) { if (en.dataType.equals(dataType)) { return en.desc; } } return null; } } Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-03 19:00:09 "},"guava/readme.html":{"url":"guava/readme.html","title":"guava教程","keywords":"","body":"Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-03 18:57:42 "},"guava/cache.html":{"url":"guava/cache.html","title":"guava-cache缓存","keywords":"","body":"Guave Cache Cache与ConcurrentMap很相似，但也不完全一样。 最基本的区别是ConcurrentMap会一直保存所有添加的元素，直到显式地移除。相对地，Guava Cache为了限制内存占用，通常都设定为自动回收元素。 在某些场景下，尽管LoadingCache不回收元素，它也是很有用的，因为它会自动加载缓存。 通常来说，Guava Cache适用于： 你愿意消耗一些内存空间来提升速度。 你预料到某些键会被查询一次以上。 缓存中存放的数据总量不会超出内存容量。 Guava Cache是单个应用运行时的本地缓存。它不把数据存放到文件或外部服务器。如果这不符合你的需求，请尝试Memcached这类工具 如果你不需要Cache中的特性，使用ConcurrentHashMap有更好的内存效率 1. 保存数据 保存数据分两种情况： 显示设置cache.put(key, value) 自动加载 CacheLoader Callable 1.1 CacheLoader //缓存接口这里是LoadingCache，LoadingCache在缓存项不存在时可以自动加载缓存 static final LoadingCache loadingCache = CacheBuilder .newBuilder()//CacheBuilder的构造函数是私有的，只能通过其静态方法newBuilder()来获得CacheBuilder的实例 .concurrencyLevel(1)//设置并发级别为1，并发级别是指可以同时写缓存的线程数 .expireAfterWrite(8, TimeUnit.SECONDS)//设置写缓存后8秒钟过期 .initialCapacity(10)//设置缓存容器的初始容量为10 .maximumSize(50)//设置缓存最大容量为1000，超过1000之后就会按照LRU最近虽少使用算法来移除缓存项 .recordStats()//设置要统计缓存的命中率 .removalListener(new RemovalListener() {//设置缓存的移除通知 @Override public void onRemoval(RemovalNotification notification) { System.out.println(notification.getKey() + \" was removed, cause is \" + notification.getCause()); } }) .build(//build方法中可以指定CacheLoader，在缓存不存在时通过CacheLoader的实现自动加载缓存 new CacheLoader() { @Override public String load(String key) throws Exception { return \"===\" + key + \"===\"; } }); 1.2 Callable 所有类型的Guava Cache，不管有没有自动加载功能，都支持get(K,Callable)方法。 这个方法返回缓存中相应的值，或者用给定的Callable运算并把结果加入到缓存中。在整个加载方法完成前，缓存项相关的可观察状态都不会更改。这个方法简便地实现了模式\"如果有缓存则返回；否则运算、缓存、然后返回\"。 final static Cache cache = CacheBuilder.newBuilder().maximumSize(1000).build(); public static void main(String[] args) throws ExecutionException { Object object = cache.get(\"name\", new Callable() { @Override public Object call() throws Exception { return \"wms\"; } }) ; System.out.println(object); } 2. 缓存回收 一个残酷的现实是，我们几乎一定没有足够的内存缓存所有数据。你你必须决定：什么时候某个缓存项就不值得保留了？ 显示回收 个别清除：Cache.invalidate(key) 批量清除：Cache.invalidateAll(keys) 清除所有缓存项：Cache.invalidateAll() 自动回收 基于容量回收 定时回收 基于引用回收。 2.1 基于容量的回收（size-based eviction） 如果要规定缓存项的数目不超过固定值，只需使用CacheBuilder.maximumSize(long)。缓存将尝试回收最近没有使用或总体上很少使用的缓存项。 final static Cache cache = CacheBuilder.newBuilder() .maximumSize(1000)//缓冲最大容量 .maximumWeight(10000)//最大权重值 .weigher(new Weigher() {//权重计算方式 @Override public int weigh(String key, User user) { return user.getAge(); } }) .build(); 2.2 定时回收（Timed Eviction） CacheBuilder提供两种定时回收的方法： expireAfterAccess(long, TimeUnit)：缓存项在给定时间内没有被读/写访问，则回收。请注意这种缓存的回收顺序和基于大小回收一样。 expireAfterWrite(long,TimeUnit)：缓存项在给定时间内没有被写访问（创建或覆盖），则回收。 expireAfterWrite如果认为缓存数据总是在固定时候后变得陈旧不可用，这种回收方式是可取的。 2.3 基于引用的回收（Reference-based Eviction） 通过使用弱引用的键、或弱引用的值、或软引用的值，Guava Cache可以把缓存设置为允许垃圾回收： 3. 刷新 刷新和回收不太一样。正如LoadingCache.refresh(K)所声明，刷新表示为键加载新值，这个过程可以是异步的。 在刷新操作进行时，缓存仍然可以向其他线程返回旧值，而不像回收操作，读缓存的线程必须等待新值加载完成。 如果刷新过程抛出异常，缓存将保留旧值，而异常会在记录到日志后被丢弃[swallowed]。 Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-03 18:54:30 "},"guava/retry.html":{"url":"guava/retry.html","title":"guava-retry重试","keywords":"","body":"guava-retry重试机制 com.github.rholder guava-retrying 2.0.0 Retryer retryer = RetryerBuilder.newBuilder() .retryIfResult(Predicates.equalTo(false)) .retryIfRuntimeException() .retryIfException() .withStopStrategy(StopStrategies.neverStop()) .build(); retryer.call(()->{ scene.setSceneKey(IDUtil.verifyCode()); return sceneService.save(scene); }); Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-03 19:22:14 "},"guava/spliter.html":{"url":"guava/spliter.html","title":"字符串拼接和切割","keywords":"","body":"字符串切割Splitter List bigbayAppIdList = Splitter.on(\",\") .omitEmptyStrings() .trimResults() .splitToList(\"123,fjdi, 88,99 , , 8 9 \") .forEach(System.out::println); 运行结果 - 123 - fjdi - 88 - 99 - 8 9 拆分器工厂 方法 描述 范例 Splitter.on(char) 按单个字符拆分 Splitter.on(‘;’) Splitter.on(CharMatcher) 按字符匹配器拆分 Splitter.on(CharMatcher.BREAKING_WHITESPACE) Splitter.on(String) 按字符串拆分 Splitter.on(“, “) Splitter.on(Pattern) Splitter.onPattern(String) 按正则表达式拆分 Splitter.onPattern(“\\r?\\n”) Splitter.fixedLength(int) 按固定长度拆分；最后一段可能比给定长度短，但不会为空。 Splitter.fixedLength(3) 拆分器修饰符 方法 描述 {++ omitEmptyStrings() ++} 从结果中自动忽略空字符串 {++trimResults() ++} 移除结果字符串的前导空白和尾部空白 {++trimResults(CharMatcher) ++} 给定匹配器，移除结果字符串的前导匹配字符和尾部匹配字符 {++ limit(int) ++} 限制拆分出的字符串数量 Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-03 19:30:19 "}}