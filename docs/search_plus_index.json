{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction gitbook install gitbook build ./ ./docs --clean gitp Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-02 21:17:28 "},"map-foreach.html":{"url":"map-foreach.html","title":"map遍历","keywords":"","body":"Java中遍历Map的几种方法 keySet values 如果只需要map的key或者value，用map的keySet或values方法无疑是最方便的 for (String key : map.keySet()) { System.out.println(key); } keySet get(key) 如果需要同时获取key和value，可以先获取key,然后再通过map的get(key)获取value 需要说明的是，该方法不是最优选择，一般不推荐使用 for (String key : map.keySet()) { System.out.println(key); System.out.println(map.get(key)); } entrySet 通过对map entrySet的遍历，也可以同时拿到key和value，一般情况下，性能上要优于上一种,这一种也是最常用的遍历方法 for (Map.Entry entry : map.entrySet()) { System.out.println(entry.getKey()); System.out.println(entry.getValue()); } Iterator 对于上面的几种foreach都可以用Iterator代替，其实foreach在java5中才被支持，foreach的写法看起来更简洁 但Iterator也有其优势：在用foreach遍历map时，如果改变其大小，会报错，但如果只是删除元素，可以使用Iterator的remove方法删除元素 Iterator> iterator = map.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry entry = iterator.next(); System.out.println(entry.getKey()); System.out.println(entry.getValue()); iterator.remove();//删除元素 } Lambda java8提供了Lambda表达式支持，语法看起来更简洁，可以同时拿到key和value，不过，经测试，性能低于entrySet,所以更推荐用entrySet的方式 map.forEach((key,value)->{ System.out.println(key); System.out.println(value); }); 总结 如果只是获取key，或者value，推荐使用keySet或者values方式 如果同时需要key和value推荐使用entrySet 如果需要在遍历过程中删除元素推荐使用Iterator 如果需要在遍历过程中增加元素，可以新建一个临时map存放新增的元素，等遍历完毕，再把临时map放到原来的map中 Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-02 21:09:07 "},"regex.html":{"url":"regex.html","title":"正则表达式","keywords":"","body":"正则表达式，一个十分古老而又强大的文本处理工具，仅仅用一段非常简短的表达式语句，便能够快速实现一个非常复杂的业务逻辑。熟练地掌握正则表达式的话，能够使你的开发效率得到极大的提升。 正则表达式经常被用于字段或任意字符串的校验，如下面这段校验基本日期格式的JavaScript代码： var reg = /^(\\\\d{1,4})(-|\\\\/)(\\\\d{1,2})\\\\2(\\\\d{1,2})$/; var r = fieldValue.match(reg); if(r==null)alert('Date format error!'); 下面是技匠整理的，在前端开发中经常使用到的20个正则表达式。 1 . 校验密码强度 密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。 ^(?=.*\\\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 2. 校验中文 字符串仅能是中文。 ^[\\\\\\u4e00-\\\\\\u9fa5]{0,}$ 3. 由数字、26个英文字母或下划线组成的字符串 ^\\\\w+$ 4. 校验E-Mail 地址 同密码一样，下面是E-mail地址合规性的正则检查语句。 [\\\\w!#$%&'*+/=?^_`{|}~-]+(?:\\\\.[\\\\w!#$%&'*+/=?^_`{|}~-]+)*@(?:[\\\\w](?:[\\\\w-]*[\\\\w])?\\\\.)+[\\\\w](?:[\\\\w-]*[\\\\w])? 5. 校验身份证号码 下面是身份证号码的正则校验。15 或 18位。 15位： ^[1-9]\\\\d{7}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}$ 18位： ^[1-9]\\\\d{5}[1-9]\\\\d{3}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}([0-9]|X)$ 6. 校验日期 “yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。 ^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$ 7. 校验金额 金额校验，精确到2位小数。 ^[0-9]+(.[0-9]{2})?$ 8. 校验手机号 下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码） ^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\\\d{8}$ 9. 判断IE的版本 IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。 ^.*MSIE [5-8](?:\\\\.[0-9]+)?(?!.*Trident\\\\/[5-9]\\\\.0).*$ 10. 校验IP-v4地址 IP4 正则语句。 \\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b 11. 校验IP-v6地址 IP6 正则语句。 (([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 12. 检查URL的前缀 应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。 if (!s.match(/^[a-zA-Z]+:\\\\/\\\\//)) { s = 'http://' + s; } 13. 提取URL链接 下面的这个表达式可以筛选出一段文本中的URL。 ^(f|ht){1}(tp|tps):\\\\/\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%&=]*)? 14. 文件路径及扩展名校验 验证windows下文件路径和扩展名（下面的例子中为.txt文件） ^([a-zA-Z]\\\\:|\\\\\\\\)\\\\\\\\([^\\\\\\\\]+\\\\\\\\)*[^\\\\/:*?\"<>|]+\\\\.txt(l)?$ 15. 提取Color Hex Codes 有时需要抽取网页中的颜色代码，可以使用下面的表达式。 ^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ 16. 提取网页图片 假若你想提取网页中所有图片信息，可以利用下面的表达式。 \\\\]*[src] *= *[\\\\\"\\\\']{0,1}([^\\\\\"\\\\'\\\\ >]*) 17. 提取页面超链接 提取html中的超链接。 (]*)(href=\"https?:\\\\/\\\\/)((?!(?:(?:www\\\\.)?'.implode('|(?:www\\\\.)?', $follow_list).'))[^\"]+)\"((?!.*\\\\brel=)[^>]*)(?:[^>]*)> 18. 查找CSS属性 通过下面的表达式，可以搜索到相匹配的CSS属性。 ^\\\\s*[a-zA-Z\\\\-]+\\\\s*[:]{1}\\\\s[a-zA-Z0-9\\\\s.#]+[;]{1} 19. 抽取注释 如果你需要移除HMTL中的注释，可以使用如下的表达式。 20. 匹配HTML标签 通过下面的表达式可以匹配出HTML中的标签属性。 \\\\s]+))?)+\\\\s*|\\\\s*)\\\\/?> Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-02 21:09:07 "},"java-generic.html":{"url":"java-generic.html","title":"泛型详解","keywords":"","body":" 引言 ​ 泛型是Java中一个非常重要的知识点，在Java集合类框架中泛型被广泛应用。本文我们将从零开始来看一下Java泛型的设计，将会涉及到通配符处理，以及让人苦恼的类型擦除。 泛型基础 泛型类 ​ 我们首先定义一个简单的Box类： public class Box { private String object; public void set(String object) { this.object = object; } public String get() { return object; } } ​ 这是最常见的做法，这样做的一个坏处是Box里面现在只能装入String类型的元素，今后如果我们需要装入Integer等其他类型的元素，还必须要另外重写一个Box，代码得不到复用，使用泛型可以很好的解决这个问题。 public class Box { // T stands for \"Type\" private T t; public void set(T t) { this.t = t; } public T get() { return t; } } ​ 这样我们的Box类便可以得到复用，我们可以将T替换成任何我们想要的类型： Box integerBox = new Box(); Box doubleBox = new Box(); Box stringBox = new Box(); 泛型方法 ​ 看完了泛型类，接下来我们来了解一下泛型方法。声明一个泛型方法很简单，只要在返回类型前面加上一个类似的形式就行了： public class Util { public static boolean compare(Pair p1, Pair p2) { return p1.getKey().equals(p2.getKey()) && p1.getValue().equals(p2.getValue()); } } public class Pair { private K key; private V value; public Pair(K key, V value) { this.key = key; this.value = value; } public void setKey(K key) { this.key = key; } public void setValue(V value) { this.value = value; } public K getKey() { return key; } public V getValue() { return value; } } ​ 我们可以像下面这样去调用泛型方法： Pair p1 = new Pair<>(1, \"apple\"); Pair p2 = new Pair<>(2, \"pear\"); boolean same = Util.compare(p1, p2); ​ 或者在Java1.7/1.8利用type inference，让Java自动推导出相应的类型参数： Pair p1 = new Pair<>(1, \"apple\"); Pair p2 = new Pair<>(2, \"pear\"); boolean same = Util.compare(p1, p2); 边界符:extends ​ 现在我们要实现这样一个功能，查找一个泛型数组中大于某个特定元素的个数，我们可以这样实现： public static int countGreaterThan(T[] anArray, T elem) { int count = 0; for (T e : anArray) if (e > elem) // compiler error ++count; return count; } ​ 但是这样很明显是错误的，因为除了short, int, double, long, float, byte, char等原始类型，其他的类并不一定能使用操作符>，所以编译器报错，那怎么解决这个问题呢？答案是使用边界符。 public interface Comparable { public int compareTo(T o); } ​ 做一个类似于下面这样的声明，这样就等于告诉编译器类型参数T代表的都是实现了Comparable接口的类，这样等于告诉编译器它们都至少实现了compareTo方法。 public static > int countGreaterThan(T[] anArray, T elem) { int count = 0; for (T e : anArray) if (e.compareTo(elem) > 0) ++count; return count; } 通配符: ? ​ 在了解通配符之前，我们首先必须要澄清一个概念，还是借用我们上面定义的Box类，假设我们添加一个这样的方法： public void boxTest(Box n) { /* ... */ } ​ 那么现在Box n允许接受什么类型的参数？我们是否能够传入Box或者Box呢？答案是否定的，虽然Integer和Double是Number的子类，但是在泛型中Box或者Box与Box之间并没有任何的关系。这一点非常重要，接下来我们通过一个完整的例子来加深一下理解。 ​ 首先我们先定义几个简单的类，下面我们将用到它： class Fruit {} class Apple extends Fruit {} class Orange extends Fruit {} ​ 下面这个例子中，我们创建了一个泛型类Reader，然后在f1()中当我们尝试Fruit f = fruitReader.readExact(apples);编译器会报错，因为List与List之间并没有任何的关系。 public class GenericReading { static List apples = Arrays.asList(new Apple()); static List fruit = Arrays.asList(new Fruit()); static class Reader { T readExact(List list) { return list.get(0); } } static void f1() { Reader fruitReader = new Reader(); // Errors: List cannot be applied to List. Fruit f = fruitReader.readExact(apples); } public static void main(String[] args) { f1(); } } ​ 但是按照我们通常的思维习惯，Apple和Fruit之间肯定是存在联系，然而编译器却无法识别，那怎么在泛型代码中解决这个问题呢？我们可以通过使用通配符来解决这个问题： static class CovariantReader { T readCovariant(List list) { return list.get(0); } } static void f2() { CovariantReader fruitReader = new CovariantReader(); Fruit f = fruitReader.readCovariant(fruit); Fruit a = fruitReader.readCovariant(apples); } public static void main(String[] args) { f2(); } ​ 这样就相当与告诉编译器， fruitReader的readCovariant方法接受的参数只要是满足Fruit的子类就行(包括Fruit自身)，这样子类和父类之间的关系也就关联上了。 PECS原则: super ​ 上面我们看到了类似的用法，利用它我们可以从list里面get元素，那么我们可不可以往list里面add元素呢？我们来尝试一下： public class GenericsAndCovariance { public static void main(String[] args) { // Wildcards allow covariance: List flist = new ArrayList(); // Compile Error: can't add any type of object: // flist.add(new Apple()) // flist.add(new Orange()) // flist.add(new Fruit()) // flist.add(new Object()) flist.add(null); // Legal but uninteresting // We Know that it returns at least Fruit: Fruit f = flist.get(0); } } ​ 答案是否定，Java编译器不允许我们这样做，为什么呢？对于这个问题我们不妨从编译器的角度去考虑。因为List flist它自身可以有多种含义： List flist = new ArrayList(); List flist = new ArrayList(); List flist = new ArrayList(); ​ 当我们尝试add一个Apple的时候，flist可能指向new ArrayList(); ​ 当我们尝试add一个Orange的时候，flist可能指向new ArrayList(); ​ 当我们尝试add一个Fruit的时候，这个Fruit可以是任何类型的Fruit，而flist可能只想某种特定类型的Fruit，编译器无法识别所以会报错。 所以对于实现了的集合类只能将它视为Producer向外提供(get)元素，而不能作为Consumer来对外获取(add)元素。 ​ 如果我们要add元素应该怎么做呢？可以使用： public class GenericWriting { static List apples = new ArrayList(); static List fruit = new ArrayList(); static void writeExact(List list, T item) { list.add(item); } static void f1() { writeExact(apples, new Apple()); writeExact(fruit, new Apple()); } static void writeWithWildcard(List list, T item) { list.add(item) } static void f2() { writeWithWildcard(apples, new Apple()); writeWithWildcard(fruit, new Apple()); } public static void main(String[] args) { f1(); f2(); } } ​ 这样我们可以往容器里面添加元素了，但是使用super的坏处是以后不能get容器里面的元素了，原因很简单，我们继续从编译器的角度考虑这个问题，对于List list，它可以有下面几种含义： List list = new ArrayList(); List list = new ArrayList(); List list = new ArrayList(); ​ 当我们尝试通过list来get一个Apple的时候，可能会get得到一个Fruit，这个Fruit可以是Orange等其他类型的Fruit。 根据上面的例子，我们可以总结出一条规律，”Producer Extends, Consumer Super”： ​ “Producer Extends” – 如果你需要一个只读List，用它来produce T，那么使用? extends T。 ​ “Consumer Super” – 如果你需要一个只写List，用它来consume T，那么使用? super T。 ​ 如果需要同时读取以及写入，那么我们就不能使用通配符了。 ​ 如何阅读过一些Java集合类的源码，可以发现通常我们会将两者结合起来一起用，比如像下面这样： public class Collections { public static void copy(List dest, List src) { for (int i=0; i 类型擦除 ​ Java泛型中最令人苦恼的地方或许就是类型擦除了，特别是对于有C++经验的程序员。类型擦除就是说Java泛型只能用于在编译期间的静态类型检查，然后编译器生成的代码会擦除相应的类型信息，这样到了运行期间实际上JVM根本就知道泛型所代表的具体类型。这样做的目的是因为Java泛型是1.5之后才被引入的，为了保持向下的兼容性，所以只能做类型擦除来兼容以前的非泛型代码。对于这一点，如果阅读Java集合框架的源码，可以发现有些类其实并不支持泛型。 ​ 说了这么多，那么泛型擦除到底是什么意思呢？我们先来看一下下面这个简单的例子： public class Node { private T data; private Node next; public Node(T data, Node next) { this.data = data; this.next = next; } public T getData() { return data; } // ... } ​ 编译器做完相应的类型检查之后，实际上到了运行期间上面这段代码实际上将转换成： public class Node { private Object data; private Node next; public Node(Object data, Node next) { this.data = data; this.next = next; } public Object getData() { return data; } // ... } ​ 这意味着不管我们声明Node还是Node，到了运行期间，JVM统统视为Node。有没有什么办法可以解决这个问题呢？这就需要我们自己重新设置bounds了，将上面的代码修改成下面这样： public class Node> { private T data; private Node next; public Node(T data, Node next) { this.data = data; this.next = next; } public T getData() { return data; } // ... } ​ 这样编译器就会将T出现的地方替换成Comparable而不再是默认的Object了： public class Node { private Comparable data; private Node next; public Node(Comparable data, Node next) { this.data = data; this.next = next; } public Comparable getData() { return data; } // ... } ​ 上面的概念或许还是比较好理解，但其实泛型擦除带来的问题远远不止这些，接下来我们系统地来看一下类型擦除所带来的一些问题，有些问题在C++的泛型中可能不会遇见，但是在Java中却需要格外小心。 问题一(不能创建泛型数组对象) 在Java中不允许创建泛型数组，类似下面这样的做法编译器会报错： List[] arrayOfLists = new List[2]; // compile-time error ​ 为什么编译器不支持上面这样的做法呢？继续使用逆向思维，我们站在编译器的角度来考虑这个问题。 ​ 我们先来看一下下面这个例子： Object[] strings = new String[2]; strings[0] = \"hi\"; // OK strings[1] = 100; // An ArrayStoreException is thrown. ​ 对于上面这段代码还是很好理解，字符串数组不能存放整型元素，而且这样的错误往往要等到代码运行的时候才能发现，编译器是无法识别的。接下来我们再来看一下假设Java支持泛型数组的创建会出现什么后果： Object[] stringLists = new List[]; // compiler error, but pretend it's allowed stringLists[0] = new ArrayList(); // OK // An ArrayStoreException should be thrown, but the runtime can't detect it. stringLists[1] = new ArrayList(); ​ 假设我们支持泛型数组的创建，由于运行时期类型信息已经被擦除，JVM实际上根本就不知道new ArrayList()和new ArrayList()的区别。类似这样的错误假如出现才实际的应用场景中，将非常难以察觉。 ​ 如果你对上面这一点还抱有怀疑的话，可以尝试运行下面这段代码： public class ErasedTypeEquivalence { public static void main(String[] args) { Class c1 = new ArrayList().getClass(); Class c2 = new ArrayList().getClass(); System.out.println(c1 == c2); // true } } 问题二(调用父类泛型方法的时候有个类型转换) ​ 继续复用我们上面的Node的类，对于泛型代码，Java编译器实际上还会偷偷帮我们实现一个Bridge method。 public class Node { public T data; public Node(T data) { this.data = data; } public void setData(T data) { System.out.println(\"Node.setData\"); this.data = data; } } public class MyNode extends Node { public MyNode(Integer data) { super(data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } } ​ 看完上面的分析之后，你可能会认为在类型擦除后，编译器会将Node和MyNode变成下面这样： public class Node { public Object data; public Node(Object data) { this.data = data; } public void setData(Object data) { System.out.println(\"Node.setData\"); this.data = data; } } public class MyNode extends Node { public MyNode(Integer data) { super(data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } } ​ 实际上不是这样的，我们先来看一下下面这段代码，这段代码运行的时候会抛出ClassCastException异常，提示String无法转换成Integer： MyNode mn = new MyNode(5); Node n = mn; // A raw type - compiler throws an unchecked warning n.setData(\"Hello\"); // Causes a ClassCastException to be thrown. // Integer x = mn.data; ​ 如果按照我们上面生成的代码，运行到第3行的时候不应该报错(注意我注释掉了第4行)，因为MyNode中不存在setData(String data)方法，所以只能调用父类Node的setData(Object data)方法，既然这样上面的第3行代码不应该报错，因为String当然可以转换成Object了，那ClassCastException到底是怎么抛出的？ ​ 实际上Java编译器对上面代码自动还做了一个处理： class MyNode extends Node { // Bridge method generated by the compiler public void setData(Object data) { setData((Integer) data); } public void setData(Integer data) { System.out.println(\"MyNode.setData\"); super.setData(data); } // ... } ​ 这也就是为什么上面会报错的原因了，setData((Integer) data);的时候String无法转换成Integer。所以上面第2行编译器提示unchecked warning的时候，我们不能选择忽略，不然要等到运行期间才能发现异常。如果我们一开始加上Node n = mn就好了，这样编译器就可以提前帮我们发现错误。 问题三(不能用类型参数创建实例) ​ 正如我们上面提到的，Java泛型很大程度上只能提供静态类型检查，然后类型的信息就会被擦除，所以像下面这样利用类型参数创建实例的做法编译器不会通过： public static void append(List list) { E elem = new E(); // compile-time error list.add(elem); } ​ 但是如果某些场景我们想要需要利用类型参数创建实例，我们应该怎么做呢？可以利用反射解决这个问题： public static void append(List list, Class cls) throws Exception { E elem = cls.newInstance(); // OK list.add(elem); } ​ 我们可以像下面这样调用： List ls = new ArrayList<>(); append(ls, String.class); ​ 实际上对于上面这个问题，还可以采用Factory和Template两种设计模式解决，感兴趣的朋友不妨去看一下Thinking in Java中第15章中关于Creating instance of types(英文版第664页)的讲解，这里我们就不深入了。 问题四(不能对泛型代码直接使用instanceof关键字) 我们无法对泛型代码直接使用instanceof关键字，因为Java编译器在生成代码的时候会擦除所有相关泛型的类型信息，正如我们上面验证过的JVM在运行时期无法识别出ArrayList和ArrayList的之间的区别： public static void rtti(List list) { if (list instanceof ArrayList) { // compile-time error // ... } } => { ArrayList, ArrayList, LinkedList, ... } ​ 和上面一样，我们可以使用通配符重新设置bounds来解决这个问题： public static void rtti(List list) { if (list instanceof ArrayList) { // OK; instanceof requires a reifiable type // ... } } 工厂模式 ​ 接下来我们利用泛型来简单的实现一下工厂模式，首先我们先声明一个接口Factory： package typeinfo.factory; public interface Factory { T create(); } ​ 接下来我们来创建几个实体类FuelFilter和AirFilter以及FanBelt和GeneratorBelt class Filter extends Part {} class FuelFilter extends Filter { public static class Factory implements typeinfo.factory.Factory { public FuelFilter create() { return new FuelFilter(); } } } class AirFilter extends Filter { public static class Factory implements typeinfo.factory.Factory { public AirFilter create() { return new AirFilter(); } } } class Belt extends Part {} class FanBelt extends Belt { public static class Factory implements typeinfo.factory.Factory { public FanBelt create() { return new FanBelt(); } } } class GeneratorBelt extends Belt { public static class Factory implements typeinfo.factory.Factory { public GeneratorBelt create() { return new GeneratorBelt(); } } } ​ Part类的实现如下，注意我们上面的实体类都是Part类的间接子类。在Part类我们注册了我们上面的声明的实体类。所以以后我们如果要创建相关的实体类的话，只需要在调用Part类的相关方法了。这么做的一个好处就是如果的业务中出现了CabinAirFilter或者PowerSteeringBelt的话，我们不需要修改太多的代码，只需要在Part类中将它们注册即可。 class Part { static List> partFactories = new ArrayList>(); static { partFactories.add(new FuelFilter.Factory()); partFactories.add(new AirFilter.Factory()); partFactories.add(new FanBelt.Factory()); partFactories.add(new PowerSteeringBelt.Factory()); } private static Random rand = new Random(47); public static Part createRandom() { int n = rand.nextInt(partFactories.size()); return partFactories.get(n).create(); } public String toString() { return getClass().getSimpleName(); } } ​ 最后我们来测试一下： public class RegisteredFactories { public static void main(String[] args) { for (int i = 0; i Copyright © wu_mingsheng@126.com 2017 all right reserved，powered by Gitbook该文件最后修改时间： 2019-12-02 21:25:10 "}}